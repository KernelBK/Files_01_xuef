不迁就
Lisp
Linux
TCP/IP
马克思
世界的本质
真相

黑客精神
1）使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。
任何事物都应该亲手尝试。
2）信息应该全部免费
3）不信任权威，提倡去中心化。
4）看能力
5你可以用计算机创造美和艺术

漠视规定，找出规避的方法
自由使用计算机

对于黑客来说，关着的门就是一种挑衅，而锁着的门则是一种侮辱。
黑客相信，只要有助于改进现状，探索未知，人们就应该允许自由地使用各种工具和信息。

！！！！！新思想
好书只有一种，那就是——读完以后，你看待世界的眼光会发生变化。

你选择什么语言，决定了你能说什么话。
编程语言就是程序员的思维方式


第一章
社会发生了什么变化？导致教育上的一切？
工业化
专业化
当工作的专业程度越来越高时，我们必须接受更长时间的训练。
当今的青少年在生产活动中，根本就是毫无用处的。

校园生活的真正问题是空虚。

我们应该怎么改变中学？学习（好的）大学

程序员 是创造者而不是研究者
只想写出有趣的软件


第二章 黑客与画家
良好的设计感

黑客搞懂“计算理论”的必要性，与画家搞懂颜料化学成分的必要性差不多。
一般，在理论上，你需要知道如何计算“时间复杂度”和“空间复杂度”；
如果你要写一个解析器，可能还需要知道状态机的概念；除此，并不需要知道特别多的理论。

软件设计

编程语言首要的特性应该是允许动态扩展。编程语言是用来帮助思考程序的，而不是用来
表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。

静态类型（static typing）
我认识的黑客，没有喜欢用静态类型语言编程。
我们需要的是一种可以随意涂抹，擦擦改改的语言，我们不想正襟危坐，把一个盛满
各种变量类型的茶杯，小心翼翼的放在自己的膝盖上，为了与一丝不苟的编译器大婶
交谈，努力地挑选词语，确保变量类型匹配，好让自己显得礼貌又周到。

大公司为了避免设计上的灾难，选择了减少设计结果的标准差。
这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。
大公司只要做到不太烂，就能赢。

已存在的产品都被城堡保护着。（word 被微软的操作系统防御着）

价格是由供给和需求共同决定的。
好玩的软件的需求量，往往比不上解决客户麻烦问题的软件的需求量。
在小剧场演出的酬劳，比不上穿着卡通大猩猩服装，在展览会上为厂商站台的酬劳。
写小说的回报比不上写广告文案的回报。
开发编程语言的收入，比不上把某些公司老掉牙的数据库连上服务器的收入。

有一份为了赚钱的工作，还有一份为了爱好的工作。

钻研某种编程语言或操作系统
白天工作，业余时间开发优美的软件。（开源软件）
业余时间写了什么软件？
如果你不爱一件事，你不可能把它做得真正优秀。
要是你很热爱编程，你就不可避免地会开发你自己的项目。

## 如何学习编程？
1 从实践中学习。动手写程序。
即使上了大学，黑客学习编程已然主要通过自己写程序。
2 黑客可以通过观看优秀的程序学会编程，看源代码。
unix源码
《unix第6版源码注释》
3 坚持一丝不苟，就能取得优秀成果。
同样的，优秀的软件也要求对美的狂热追求。

如何合作
将项目分割成严格定义的模块，每一个模块由一个人明确负责。
模块和模块之间的接口经过精心设计，如果可能的话，最好把文档说明
写得想编程语言规范那样清晰。

大多数软件是为人类用户准备的。
要时刻考虑到用户的人性需要。站在用户的角度思考问题

了解别人对于事情的看法，并不代表你为它的利益屈服。
某些情况下，了解对手正是为了打击对手。

软件的部分功能就是解释自身。
为了写出优秀软件，你必须假定用户对你的软件基本上一无所知。

程序是写给人看的。

第三章 不能说的话
古今 中西 对比

禁忌如何产生
（马克思）

### 为什么要这么做
我要亲眼看一下，然后自己做决定
想要做出优秀作品，你需要一个什么问题都能思考的大脑。
在科学领域，质疑他人的结论和公认的假设尤其重要。（卡尔波普尔）


第5章
利用语言优势
Lisp
common lisp

在unix系统上发布软件

规范统一的网页制作

第6章

世界财富总量？
一国财富的性质和原因
《国民财富的性质和原因的研究》
《资本论》

优秀程序员||平庸程序员

最富有的5%占有全社会一半以上的财富。
最顶尖的5%的程序员写出了全世界99%的优秀软件。

### 什么是工作
深入观察现实

公司一切行为的目的都是盈利，从而生存下去。
满足人们的某种需要。

财富意味着人们需要的东西，那么把商品送到顾客手中也是人们需要的。

真正需要的是做出人们需要的东西，而不是加入某个公司。
对大多数人来说，最好的选择可能是为某个显存公司打工。


可测量性与可放大性


不是小村庄的那种小，而是需要全明星第一阵容的那种小。

创业公司 大公司
游击队  正规军

解决用户关心的问题

## 财富与权力
人类历史
马克思
欧洲为何变得如此强大？
允许赚取大钱的人保住自己的财富，作为法律。
藏富于民，引爆他们的潜力。


第7章
财富（资源）创造与再分配

如何使用新技术？

流水线生产

无所事事使人感到孤独和消沉

绝对贫穷与相对贫穷

如果你让他致富，他就会造出一台拖拉机，使你不再需要使用马匹耕田了。
学会利用新工具，新技术来提高生产力。

第10章 编程语言解析
所有及其都有一张操作命令清单，让你可以控制它。

高级语言(可移植性)
## 抽象性

有些设计者认为编程语言应该防止程序员干蠢事（如java），
另一些则认为程序员可以用编程语言干一切他们想干的事。（Perl）

静态类型 与 动态类型语言

## 面向对象编程
计算二维图形的面积
：首先判断它是什么图形，再用相应的公式计算面积。
面向对象：不同的类型实现为不同的类，对象调用方法，
多态机制自会根据对象的实际类型调用相应代码。

面向对象编程的优点在于，如果你需要修改程序，计算另一种图形的面积，
你只需要再另外增加另一块相应的代码就可以了，甚至可以不修改程序的其他部分。


第11章
概率空间
不管编程语言怎么变，它的形式总是很有限的。

语言的设计思想

任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）
以及除运算符以外的其他部分（原则上可以用基本运算符表达出来）

基本运算符是一门语言能否长期存在的最重要因素。
买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置
是没法变的。

慎重选择公理还不够，还要控制它的规模。
数学家觉得公理越少越好，我觉得他们说到了点子上。

你仔细审视一种语言的内核，考虑哪些部分可以被摒弃，这至少也是一种有用的训练。


数据结构
字符串，列表
字符串是列表的一个子集，那为何还要把字符串单列为一种数据类型呢？
（为了计算速度）

语言的表达能力

数组是散列表的一个子集
在逻辑上其实不需要对整数设置单独的表示法，因为可以把它们也看作列表（甚至过程），
整数n可以用一个n个元素的列表表示。这同样能完成数学运算，只是效率太低。

## 语言中的基本公理

语言的内核语义

## 可重用性
某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它使用了
面向对象编程，而是因为它的开发方法是自下而上的。
以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为采用
面向对象或者其他编程方法。

## 并行计算

# 宏

# 解析树

# XML格式数据/json格式数据
生成数据是第一步（sicp）
数据可以来自于很多端口/接口（网络 + 协议）
《How2Design program》
《sicp》
《集体智慧编程》

交换信息 数据通信

# 设计编程语言

第12章

雷蒙德推荐的hacker5种语言，我发现Lisp有一个功能，其他4种都没有。
我觉得，没有宏(macro)的话，那些语言怎么编程呢？
在实际运用种，如果没有其他Lisp功能(如闭包和函数的rest参数)的配合，
Lisp的宏也不会有太大作用。
Lisp宏的作用与括号有关。它们是Lisp与其他语言存在巨大差异的外在表现。

Lisp代码由Lisp数据对象构成！！！
其他语言的源代码一般由字符组成，字符串是主要数据类型之一，但是Lisp
语言不完全是这样。经过解析器处理之后，Lisp代码就变成了你可以遍历的
数据结构。

如果你理解编译器的工作原理，那么事实是，与其说Lisp有一种很奇特的语法，
还不如说它根本没有语法。
一般的源代码程序经过编译器解析会生成解析树。Lisp的奇特之处就在于，你可以
完全写出程序，控制这种解析树，进行任意存取操作。
Lisp的这种程序就叫做宏，它们用来生成其他程序。


编程语言，程序员的思考模式。

普通的程序员使用普通的编程语言。

动态类型语言
闭包
宏

通过查看招聘岗位，判断公司做什么产品。

什么情况下应该使用什么语言？
合适的程序员 + 函数库

令人舒服的想法总是易于被接受的。

Perl

他在问Python程序能不能像处理数据一样，优雅地处理Python代码。
“不行。John, Python做不到。” Peter就回答了这一句，然后静静地等待，
准备接受教授的质疑，但老人没有再说什么了。此时，无语已胜千言。

《RubyUnder a Microscope》是一本在豆瓣上得分高达9.2的一本书，作者叫Pat Shaughnessy，这位大牛在一篇博客中讲“垃圾回收器”时顺带讲到了LISP。程序中的“垃圾回收”是什么？这可并不是普通的垃圾回收，它主要完成三个重要任务：1、为新的对象分配内存；2、标记垃圾对象；3、回收垃圾对象占用的内存。事实上，垃圾回收是一个令人着迷的主题：垃圾回收算法不仅是计算机科学历史一个重要的部分，更是前沿研究的一个主题。
这位大牛是这么说垃圾回收器的：“我认为垃圾回收器是一个应用的心脏。正如心脏为身体的其他部分提供血液和养料一样，垃圾回收器提供内存和对象供程序使用。如果你的心脏停跳，你将活不了几秒。如果垃圾回收器停止运行或者变慢，就像动脉阻塞一样，你的程序将变的慢下来，最后死掉！”
简言之，如果算法和业务逻辑比做是应用程序的大脑，Pat Shaughnessy把垃圾回收系统看作是应用程序的心脏。但这颗心脏不是一开始都有。程序语言中其实早期是不能实现垃圾回收机制的，是约翰·麦卡锡在1960年在Lisp中首次实现了垃圾回收机制。
Lisp不仅是第一个函数式编程语言，并且包含了计算机科学中许多突破性的进展。其中之一便是通过垃圾回收机制自动管理内存。

1959年，麦卡锡基于阿隆索·邱奇的l-演算和西蒙、纽厄尔首创的“表结构”，
开发了著名的LISP语言，成为人工智能界第一个最广泛流行的语言。
并于1960年正式发表关于这一课题的学术文章《符号表达式的递归函数及其运算》。
有评论称，该论文中对编程的贡献有如欧几里德对几何的贡献。麦卡锡在论著中展
示了如何利用尽可能少的简单操作符和函数记号，去构造出一个完整的编程语言。
其主要思想是用一种简单的数据结构表(list)来表示代码和数据，所以称这种 
语言为LISP, 即List Processing。
“Lisp”是“listprocessing language”（表处理语言）的缩写。确如其名，
Lisp中所有的数据都用表来表示。这些表都被包含在圆括号中。比如说，
(Robert taught Dennis)可能就是表示“罗伯特教丹尼斯”这个句子的一个表。
在这种情况下，顺序是很重要的，因为它指明了是谁在教谁。


逻辑 + 数学

Lisp本质上是数学，这是它如此强大的原因。

《高等数学》《线性代数》
把数学认真看下？
《对我启发最大的数学学习方法（转自知乎）》
《图灵数学统计学丛书》
《费曼物理学》


Lisp包含的思想：
1）条件结构
2）函数也是一种数据类型
3）递归
4）变量的动态类型
5）垃圾回收机制
6）程序由表达式组成
7）符号类型
8）代码使用符号和常量组成的树形表示法
9）无论什么时候，整个语言都是可用的。

用一门语言自己的数据结构来表达语言是非常强大的功能。8）9）意味着
你可以写出一种自己编程的程序。最常用的做法是使用宏。

大多数的编程任务可能只要写一些很小的“胶水程序”，然后再把这些小程序连起来就行了。
你可以用自己熟悉的编程语言或用对于特定项目来说有着最强大函数库的语言来写这些
“胶水程序”。

Lisp的最大优势体现在编程任务的另一端，就是在激烈竞争的条件下开发那些解决肯能难
问题的复杂程序。

ITA的软件的核心是一个20万行的Common Lisp程序，它的搜索能力比竞争对手高出许多个
数量级。


使用一种不常见的语言会出现的问题我想到了三个：你的程序可能无法很好滴与使用其他
语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。

衡量语言的编程能力的最简单方法可能就是看代码数量。
所谓高级语言，就是能够提供更强大抽象能力的语言。
语言的编程能力越强大，写出来的程序就越短（当然不是指字符数量，
而是指独立的语法单位）

强大的编程语言如何能让你写出更短的程序。
一个技巧就是使用“自下而上”的编程方法。你不是用基础语言开发应用程序，
二十载基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。

一种出色的工具到了真正优秀的黑客手里，可以发挥出更大的威力。

不同编程语言的编程能力是不一样。
如果你想在软件业获得成功，就使用你知道的最强大的语言，用它解决你知道的
最难的问题，并等待竞争对手的经理做出自甘平庸的选择。


？？？词法变量

？？？闭包
在面向对象编程的语言中，你能够在有限程度上模拟一个闭包（即一个函数，通过它
可以引用由包含这个函数的代码所定义的变量）。

你定义一个类(class)，里面有一个方法和一个属性，用于替换封闭作用域(enclosing scope)
中的所有变量。这有点类似于让程序员自己做代码分析，本来这应该是由支持词法作用域
(lexical scope)的编译器完成的。
如果有多个函数，同时指向相同的变量，那么这种方法就会失效，但是在这个简单例子中，
已经足够。
Python高手看来也同意这是解决这个问题比较好的方法：(累加器)
def foo(n):
	class acc:
		def __init__(self, s):
			self.s = s
		def inc(self, i):
			self.s += inc
			return self.s
	return acc(n).inc

Lisp:
(define (acc n)
	(lamada (i) (+ n i)))
	
如果你想解决一个困难的问题，关键不是你使用的语言是否强大，而是好几个因素
同时发挥作用：
a)使用一种强大的语言
b)为这个难题写一个事实上的解释器
或者c)你自己变成这个难题的人肉编译器。
这种实践不仅很普遍，而且已经制度化了。举例，在面向对象编程的世界中，我们
大量听到“模式”(pattern)这个词，我觉得那些“模式”就是现实中的因素(c)，也就是
人肉编译器。当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。
程序的形式应该仅仅反映它所要解决的问题。
代码中其他任何外加的形式都是一个信号，（至少对我来说）表明我对问题的抽象
还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码通过宏的扩展自动实现。


一种语言必须是某一个流行的计算机系统的脚本语言，才会变得流行。
C是Unix的脚本语言，后来的Perl和Python也是如此。
Tcl是Tk的脚本语言，Visual Basic是Windows的脚本语言，
（某种形式的）Lisp是Emacs的脚本语言，
PHP是网络服务器的脚本语言，
Java和JS是浏览器脚本语言。


“编程”其实是个及物动词，黑客一般都是为某个系统编程。
存在免费的实现。
编程语言还需要有一本介绍它的书。
编程语言还应该有在线文档。
书店是程序员发现和学习新语言的最重要的场所之一。

## 简洁性
简洁性最重要的方面就是要使得语言更抽象。

简洁性是静态类型类型语言的力所不及之处。不考虑其他因素时，没人愿意
在程序的头部写上一大堆的声明语句。
只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。

单个的语法单位也应该很简短。

## 可编程性(Hackability)
这种语言能够帮助自己做到想做的事
语言设计者应该假定他们的目标用户是一个天才，而不是傻瓜。
如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。
你也许能够阻止他引用另一个模块中的变量，但是你没法防止他日日夜夜不知疲倦地
写出结构混乱的程序去解决完全错误的问题。

## 一次性程序
什么样的程序适合写一次性程序？
首先，它必须很容易装备。
很容易与使用者互动。一种有命令行界面，可以实时反馈。

### 函数库
Perl应在它具有操作字符串的巨大函数库。
这类函数库对一次性程序特别重要，因为开发一次性程序的原始目的往往就是转化或提取字符串。

设计优秀的函数库是很难的，并不只是写一大堆代码而已。
一旦函数库数量变得太多，找到一个你需要的函数有时候还不如自己动手写来的快。
函数库的设计基础与语言内核一样，都是一个小规模的正交运算符集合。
函数库的使用应该符合程序员的直觉，让他可以猜得出哪个函数能满足自己的需要。

## 效率
运行速度只取决于一些关键的瓶颈。(平静到底在哪里)
编程时提高代码运行速度的关键是使用好的性能分析器。

程序运行时性能分析器 图形实时显示
如内存情况

性能分析器甚至有可能自动找出不合理的算法。

受限于IO速度

内存瓶颈
编程语言在这方面也能发挥作用，对线程的良好支持将使得所有用户共享一个内存堆。
持久化对象和语言内核级别的延迟加载支持也有助于减少内存需求。


## 时间
自然成长式
大爆炸式

## 再设计

？？？垂直接口
？？？水平接口






