


JLex + 正则--> 词法分析器

Lex是一个程序生成器，它被设计用来对输入字符流进行词法处理。它接受一种高级的、面向问题的说明书，
并用它匹配字符串中的字符、生成能够识别正则表达式的程序。正则表达式通过用户输入的代码说明书给入。
Lex识别这些表达式，并且将输入流分成一些匹配这些表达式的字符串。在这些字符串的分界处，用户提供的程序片段被执行。
Lex代码文件将正则表达式和程序片断关联。对每一条输入到由Lex生成程序的表达式，相应的代码片段被执行。

Lex将用户输入的表达式和动作actions（在这篇文章中被称作源代码）转换为宿主语言；生成的程序叫做yylex。
yylex识别字符流中的表达式（本文称作输入流），并且当每一个表达式被检测出来后，输出相应的动作。

作为一个简单的例子，考虑一个用于删除输入中每行结尾处所有空白符的程序。

%%

[ /t]+$
;

是其全部。程序包含%%界定符表示规则的开始，以及一条规则。这条规则包括一条正则表达式，用来匹配一个或多个、仅出现在行尾字符串中的
空格或者制表符（根据C语言传统，显式的写为/t）。中括号表明字符类由空格和制表符组成；+表示“一个或者多个……”；而$就像在QED中一样表示“行尾”。
没有提供具体的动作，所以Lex生成的程序（yylex）会忽略这些字符。其他的字符会被拷贝。

Lex由源文件中的正则表达式产生确定的有穷状态自动机。

Lex将匹配的文本存在名为yytext的字符数组中。
请注意，Lex通常用于将输入流分隔开，而不是查找所有满足表达式的匹配。这意味着每一个字符解释且仅解释一次。

在lex中，有特殊意义的运算符要加转义字符\，如+、*及*、/


??????
# 如何区分 if 和 fif变量名
"if"
[a-z]+
最长匹配原则
# 如何获得匹配字符串的结束位置是方便的?




### 词素？
1. keywords

2. 运算符
运算符为
" / [ ] ˆ − ? . * + | ( ) $ / { } % < >
如果它们被用于文本字符，则必须使用转义字符（escape）
3. identifier

4. 分隔符
