


# 6.1 栈
1. Rails
入栈 出栈序列

2. 简单的表达式解析可以借助栈来完成。

# 6.2 链表

提示6-4：为了方便起见，常常在链表的第一个元素之前放一个虚拟结点。

提示6-6：如果数据结构上的某一个操作很耗时，有时可以用加标记的方式处理，而不
需要真的执行那个操作。但同时，该数据结构的所有其他操作都要考虑这个标记。

# 6.3 二叉树
提示6-11：给定一棵包含2 d 个结点（其中d为树的高度）的完全二叉树，如果把结点从
上到下从左到右编号为1,2,3……，则结点k的左右子结点编号分别为2k和2k+1

提示6-16：可以用数组来实现二叉树，方法是用整数表示结点编号，left[u]和right[u]
分别表示u的左右子结点的编号。
虽然包括笔者在内的很多选手更喜欢用数组方式实现二叉树（因为编程简单，容易调
试），但仍然需要具体问题具体分析。例如，用指针直接访问比“数组+下标”的方式略快，
因此有的选手喜欢用“结构体+指针”的方式处理动态数据结构，但在申请结点时仍然用这里
的“动态化静态”的思想。


提示6-17：可以用静态数组配合空闲列表来实现一个简单的内存池。虽然在大多数算
法竞赛题目中用不上，但是内存池技术在高水平竞赛以及工程实践中都极为重要。


第7章 暴力求解法
连续子序列有两个要素：起点和终点，因此只需枚举起点和终点即可。


提示7-2：如果某问题的解可以由多个步骤得到，而每个步骤都有若干种选择（这些候
选方案集可能会依赖于先前作出的选择），且可以用递归枚举法实现，则它的工作方式可以
用解答树来描述。


## 回溯法
回溯法的应用范围很广，只要能把待求解的问题分成不太多的步骤，每个步骤又只有不
太多的选择，都可以考虑应用回溯法。为什么说“不太多”呢？想象一棵包含L层，每层的分
支因子均为b的解答树，其结点数高达...。无论是b太大还是L太大，结点
数都会是一个天文数字。

回溯法是初学者学习暴力法的第一个障碍，学习时间短则数天，长则数月甚至一年
以上。

最简单的思路是把问题转化为“从64个格子中选一个子集”，使得“子集中恰好有8个格
子，且任意两个选出的格子都不在同一行、同一列或同一个对角线上”。这正是子集枚举问
题。然而，64个格子的子集有2^64 个，太大了，这并不是一个很好的模型。

第二个思路是把问题转化为“从64个格子中选8个格子”，这是组合生成问题。根据组合
数学，有 种方案，比第一种方案优秀，但仍然不够好。

经过思考，不难发现以下事实：恰好每行每列各放置一个皇后。如果用C[x]表示第x行
皇后的列编号，则问题变成了全排列生成问题。而0～7的排列一共只有8!=40320个，枚举量
不会超过它。


提示7-9：在编写递归枚举程序之前，需要深入分析问题，对模型精雕细琢。一般还应
对解答树的结点数有一个粗略的估计，作为评价模型的重要依据


提示7-10：当把问题分成若干步骤并递归求解时，如果当前步骤没有合法选择，则函
数将返回上一级递归调用，这种现象称为回溯。正是因为这个原因，递归枚举算法常被称为
回溯法，应用十分普遍。

提示7-11：如果在回溯法中使用了辅助的全局变量，则一定要及时把它们恢复原状。
特别地，若函数有多个出口，则需在每个出口处恢复被修改的值。




如果不考虑效率，本题可以递归枚举全排列，分别计算带宽，然后选取最小的一种方
案。能否优化呢？和八皇后问题不同的是：八皇后问题有很多可行性约束（feasibility
constraint），可以在得到完整解之前避免扩展那些不可行的结点，但本题并没有可行性约束
——任何排列都是合法的。难道只能扩展所有结点吗？当然不是。



提示7-14：在求最优解的问题中，应尽量考虑最优性剪枝。这往往需要记录下当前最
优解，并且想办法“预测”一下从当前结点出发是否可以扩展到更好的方案。具体来说，先计
算一下最理想情况可以得到怎样的解，如果连理想情况都无法得到比当前最优解更好的方
案，则剪枝。


7.5　路径寻找问题
在第6章中曾经介绍过图的遍历。很多问题都可以归结为图的遍历，但这些问题中的图
却不是事先给定、从程序读入的，而是由程序动态生成的，称为隐式图。本节和前面介绍的
回溯法不同：回溯法一般是要找到一个（或者所有）满足约束的解（或者某种意义下的最优
解），而状态空间搜索一般是要找到一个从初始状态到终止状态的路径。

提示7-15：路径寻找问题可以归结为隐式图的遍历，它的任务是找到一条从初始状态
到终止状态的最优路径，而不是像回溯法那样找到一个符合某些要求的解。


