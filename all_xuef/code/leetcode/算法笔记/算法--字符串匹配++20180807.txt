


1. KMP
单模式匹配

一点直观的理解：
在模式串P的匹配过程中，假如在某个位置失配了，我们希望能不回溯从头匹配，因为在之前的匹配过程中已经积累了足够的信息，
于是问题完全变成了在每个位置计算模式串后缀和前缀的最长匹配，一个简单的动态规划。

http://www.matrix67.com/blog/archives/115
https://www.zhihu.com/question/21923021
2. Trie
字符含有状态

3. AC自动机	
多模式匹配
https://blog.csdn.net/sealyao/article/details/4560427
https://zh.wikipedia.org/zh-hans/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95
在计算机科学中，Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，[1]
用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。
算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，
如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。

该算法主要依靠构造一个有限状态机（类似于在一个trie树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串
失败时进行回退（例如设Trie树的单词cat匹配失败，但是在Trie树中存在另一个单词cart，失配指针就会指向前缀ca），
转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。

当一个字典串集合是已知的(例如一个计算机病毒库), 就可以以离线方式先将自动机求出并储存以供日后使用，在这种情
况下，算法的时间复杂度为输入字符串长度和匹配数量之和。

UNIX系统中的一个命令fgrep就是以AC自动机算法作为基础实现的。

4. Rabin-Karp
同觉得没必要纠结于KMP算法，这里推荐另外一个有趣的算法，叫Rabin-Karp算法，理解起来相对容易。
假设有一个大的字符串t,长度为n,和一个要匹配的字符串s，长度为m，n>>m。 

Rabin-Karp算法的想法是为t每一个长度为m的子串求一个hash值，然后和s的hash值匹配， 如果匹配上了，再去匹配字符串本身。

正常情况下计算hash值的复杂度是o(m)， 所以整个算法依然是o(mn)。但是如果设计较好的hash算法， 让每个子串的hash值通过
它前一个子串的hash值快速算出来（因为他们毕竟有m-1个字符完全一样）， 这样平均复杂度就能降低到o(n)。一个最简单的hash
函数即m个元素的和。在已知前一个字符串的hash值以及两个字符串的差异之后，可以快速求出后一个字符串的hash值。

作者：施佳鑫
链接：https://www.zhihu.com/question/21923021/answer/37428741


two way algorithm












