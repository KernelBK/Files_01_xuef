




题目大意：
对于一棵无向树，我们可以选择它的任意节点作为根。得到的结果就是有根树。在所有可能的有根树中，高度最小的称为最小高度树（MHT）。
给定一个无向图，编写函数找出所有的最小高度树，并返回其根标号的列表。

格式：

图包含n个节点，标号为0到n-1。给定数字n以及一列无向边（每条边用一对标号表示）

你可以假设边没有重复。由于所有边都是无方向的，因此[0, 1]与[1, 0]是等价的。因而它们不会同时出现在边集合中。

测试用例如题目描述。

提示：

最多可能存在多少个MHT？

注意：

(1) 根据维基百科的定义：“一棵树是一个满足这样性质的无向图：任意两个节点之间只存在一条路径相连。或者说，任意不包含简单环路的连通图叫做树”。

(2) 有根树的高度为从根部到叶子节点的路径中最长的那一条的边数。



这道题虽然是树的题目，但是跟其最接近的题目是Course Schedule 课程清单和Course Schedule II 课程清单之二。
由于LeetCode中的树的题目主要都是针对于二叉树的，而这道题虽说是树但其实本质是想考察图的知识，这道题刚开始在拿到的时候，
我最先想到的解法是遍历的点，以每个点都当做根节点，算出高度，然后找出最小的，但是一时半会又写不出程序来，
于是上网看看大家的解法，发现大家推崇的方法是一个类似剥洋葱的方法，就是一层一层的褪去叶节点，
最后剩下的一个或两个节点就是我们要求的最小高度树的根节点，这种思路非常的巧妙，而且实现起来也不难，
跟之前那到课程清单的题一样，我们需要建立一个图g，是一个二维数组，其中g[i]是一个一维数组，保存了i节点可以到达的所有节点。
我们开始将所有只有一个连接边的节点(叶节点)都存入到一个队列queue中，然后我们遍历每一个叶节点，通过图来找到和其相连的节点，
并且在其相连节点的集合中将该叶节点删去，如果删完后此节点也也变成一个叶节点了，加入队列中，再下一轮删除。
那么我们删到什么时候呢，当节点数小于等于2时候停止，此时剩下的一个或两个节点就是我们要求的最小高度树的根节点啦

xuef:
1. 如何确定最外围的那一层(叶节点?单边节点?), 并删除之。
2. 何时终止












