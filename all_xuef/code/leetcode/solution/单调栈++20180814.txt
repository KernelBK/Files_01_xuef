

利用单调栈的特性，可以在线性时间内求得每一个点它的左右第一个比它大/小的点。

单调栈何时用： 为任意一个元素找左边和右边第一个比自己大/小的位置，用单调栈
用递增单调栈还是递减单调栈：递减栈会剔除波谷，留下波峰；递增栈剔除波峰，留下波谷

https://zhuanlan.zhihu.com/p/26465701
题目，Leetcode 84. Largest Rectangle in Histogram，85. Maximal Rectangle.
单调栈是一种理解起来很容易，但是运用起来并不那么简单的数据结构。一句话解释单调栈，就是一个栈，
里面的元素的大小按照他们所在栈内的位置，满足一定的单调性。那么到底什么时候用这个单调栈，怎么
用单调栈呢。下面我们来看几个例子。

先来分享一道非常简单的，我本人在google interview中遇到的题目。（大雾，当时并没有做出来。）

题目是这样的，给一个数组，返回一个大小相同的数组。返回的数组的第i个位置的值应当是，对于原数组中的第i个元素，
至少往右走多少步，才能遇到一个比自己大的元素（如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上-1）。

简单的例子：

input: 5,3,1,2,4

return: -1 3 1 1 -1

explaination: 对于第0个数字5，之后没有比它更大的数字，因此是-1，对于第1个数字3，需要走3步才能达到4（第一个比3大的元素），
对于第2和第3个数字，都只需要走1步，就可以遇到比自己大的元素。对于最后一个数字4，因为之后没有更多的元素，所以是-1。

我们维护这样一个单调递减的stack，stack内部存的是原数组的每个index。每当我们遇到一个比当前栈顶所对应的数（就是input[monoStack.top()]）
大的数的时候，我们就遇到了一个“大数“。这个”大数“比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。我们弹出栈内所有对应数
比这个数小的栈内元素，并更新它们在返回数组中对应位置的值。因为这个栈本身的单调性，当我们栈顶元素所对应的数比这个元素大的时候，我们可
以保证，栈内所有元素都比这个元素大。对于每一个元素，当它出栈的时候，说明它遇到了自己的next greater element，我们也就要更新return数组
中的对应位置的值。如果一个元素一直不曾出栈，那么说明不存在next greater element，我们也就不用更新return数组了。

这里作者在数组末尾加入了一个height 0，来强迫程序在结束前，将所有元素按照顺序弹出栈。是一个很巧妙的想法。在这个例子中，对于每一个元素
都只有一次入栈和出栈的操作，因此时间复杂度只有O(n)。



最后再总结一下单调栈。单调栈这种数据结构，通常应用在一维数组上。如果遇到的问题，和前后元素之间的大小关系有关系的话，
（例如第一题中我们要找比某个元素大的元素，第二个题目中，前后的bar的高低影响了最终矩形的计算），我们可以试图用单调栈来解决。
在思考如何使用单调栈的时候，可以回忆一下这两题的解题套路，然后想清楚，如果使用单调栈，每个元素出栈时候的意义。
最后的时间复杂度，因为每个元素都出栈入栈各一次，所以是线性时间的复杂度。



你提到了两个题, 分别是 
316 Remove Duplicate Letters, 
402 Remove K Digits 

其实不止, 你会用到单调栈的还包括有 
84 Largest Rectangle in Histogram | 85 (84变形), 42 Trapping Rain Water, 
739. Daily Temperatures 321. Create Maximum Number.

在我看来, 这些题里面多多少少都用到了 155 min stack | max stack 这种形式, 只不过具体计算方法略有差别. 









