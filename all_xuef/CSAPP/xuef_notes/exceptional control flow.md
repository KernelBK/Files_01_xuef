

## ECF



### 异步异常（中断）

异步异常(Asynchronous Exception)称之为中断(Interrupt)，是由处理器外面发生的事情引起的。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生。CPU对其的响应也完全是被动的，但是可以屏蔽掉[1]。这种情况下：

- 需要设置处理器的中断指针(interrupt pin)
- 处理完成后会返回之前控制流中的『下一条』指令

比较常见的中断有两种：计时器中断和 I/O 中断。计时器中断是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。I/O 中断类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕，都会触发这样的中断。



### 同步异常

同步异常(Synchronous Exception)是因为执行某条指令所导致的事件，分为陷阱(Trap)、故障(Fault)和终止(Abort)三种情况。

| 类型   | 原因       | 行为       | 示例               |
| ---- | -------- | -------- | ---------------- |
| 陷阱   | 有意的异常    | 返回到下一条指令 | 系统调用，断点          |
| 故障   | 潜在可恢复的错误 | 返回到当前指令  | 页故障(page faults) |
| 终止   | 不可恢复的错误  | 终止当前程序   | 非法指令             |

这里需要注意三种不同类型的处理方式，比方说陷阱和中断一样，会返回执行『下一条』指令；而故障会重新执行之前触发事件的指令；终止则是直接退出当前的程序。

### 系统调用示例

系统调用看起来像是函数调用，但其实是走异常控制流的，在 x86-64 系统中，每个系统调用都有一个唯一的 ID，如

| 编号   | 名称       | 描述      |
| ---- | -------- | ------- |
| 0    | `read`   | 读取文件    |
| 1    | `write`  | 写入文件    |
| 2    | `open`   | 打开文件    |
| 3    | `close`  | 关闭文件    |
| 4    | `stat`   | 获取文件信息  |
| 57   | `fork`   | 创建进程    |
| 59   | `execve` | 执行一个程序  |
| 60   | `_exit`  | 关闭进程    |
| 62   | `kill`   | 向进程发送信号 |

举个例子，假设用户调用了 `open(filename, options)`，系统实际上会执行 `__open` 函数，也就是进行系统调用 `syscall`，如果返回值是负数，则是出错



## 进程

进程是计算机科学中最为重要的思想之一，进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。

### 进程切换 Process Context Switch

### 进程控制 Process Control

**系统调用的错误处理**

在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 `errno` 这个全局变量来表示错误的原因。使用的时候记住两个规则：

1. 对于每个系统调用都应该检查返回值
2. 当然有一些系统调用的返回值为 void，在这里就不适用

例如，对于 `fork()` 函数，我们应该这么写：

```c
if ((pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(0);
}
```



**获取进程信息**

我们可以用下面两个函数获取进程的相关信息：

- `pid_t getpid(void)` - 返回当前进程的 PID
- `pid_t getppid(void)` - 返回当前进程的父进程的 PID

我们可以认为，进程有三个主要状态：

- 运行 Running
  - 正在被执行、正在等待执行或者最终将会被执行
- 停止 Stopped
  - 执行被挂起，在进一步通知前不会计划执行
- 终止 Terminated
  - 进程被永久停止

另外的两个状态称为新建(new)和就绪(ready)，这里不再赘述。

**终止进程**

在下面三种情况时，进程会被终止：

1. 接收到一个终止信号
2. 返回到 `main`
3. 调用了 `exit` 函数

`exit` 函数会被调用一次，但从不返回，具体的函数原型是

```c
// 以 status 状态终止进程，0 表示正常结束，非零则是出现了错误
void exit(int status)
```

**创建进程**

调用 `fork` 来创造新进程。这个函数很有趣，执行一次，但是会返回两次，具体的函数原型为

```c
// 对于子进程，返回 0
// 对于父进程，返回子进程的 PID
int fork(void)
```

子进程几乎和父进程一模一样，会有相同且独立的虚拟地址空间，也会得到父进程已经打开的文件描述符(file descriptor)。比较明显的不同之处就是进程 PID 了。

有以下几点需要注意：

- 调用一次，但是会有两个返回值
- 并行执行，不能预计父进程和子进程的执行顺序
- 拥有自己独立的地址空间（也就是变量都是独立的），除此之外其他都相同
- 在父进程和子进程中 `stdout` 是一样的（都会发送到标准输出）

### 回收子进程

即使主进程已经终止，子进程也还在消耗系统资源，我们称之为『僵尸』。为了『打僵尸』，就可以采用『收割』(Reaping) 的方法。父进程利用 `wait` 或 `waitpid` 回收已终止的子进程，然后给系统提供相关信息，kernel 就会把 zombie child process 给删除。

如果父进程不回收子进程的话，通常来说会被 `init` 进程(pid == 1)回收，所以一般不必显式回收。但是在长期运行的进程中，就需要显式回收（例如 shell 和 server）。

如果想在子进程载入其他的程序，就需要使用 `execve` 函数，具体可以查看对应的 man page，这里不再深入。

## 信号 Signal

Linux 的进程树，可以通过 `pstree` 命令查看

对于前台进程来说，我们可以在其执行完成后进行回收，而对于后台进程来说，因为不能确定具体执行完成的时间，所以终止之后就成为了僵尸进程，无法被回收并因此造成内存泄露。

这怎么办呢？同样可以利用异常控制流，当后台进程完成时，内核会中断常规执行并通知我们，具体的通知机制就是『信号』(signal)。

**信号是 Unix、类 Unix 以及其他 POSIX 兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。**

这样看来，信号其实是类似于异常和中断的，是由内核（在其他进程的请求下）向当前进程发出的。信号的类型由 1-30 的整数定义，信号所能携带的信息极少，一是对应的编号，二就是信号到达这个事实。下面是几个比较常用的信号的编号及简介：

| 编号   | 名称      | 默认动作     | 对应事件                       |
| ---- | ------- | -------- | -------------------------- |
| 2    | SIGINT  | 终止       | 用户输入 ctrl+c                |
| 9    | SIGKILL | 终止       | 终止程序（不能重写或忽略）              |
| 11   | SIGSEGV | 终止且 Dump | 段冲突 Segmentation violation |
| 14   | SIGALRM | 终止       | 时间信号                       |
| 17   | SIGCHLD | 忽略       | 子进程停止或终止                   |

内核通过给目标进程发送信号，来更新目标进程的状态，具体的场景为：

- 内核检测到了如除以零(SIGFPE)或子进程终止(SIGCHLD)的系统事件
- 另一个进程调用了 `kill` 指令来请求内核发送信号给指定的进程

目标进程接收到信号后，内核会强制要求进程对于信号做出响应，可以有几种不同的操作：

- **忽略**这个型号
- **终止**进程
- **捕获**信号，执行信号处理器(signal handler)，类似于异步中断中的异常处理器(exception handler)

如果信号已被发送但是未被接收，那么处于等待状态(pending)，同类型的信号至多只会有一个待处理信号(pending signal)，一定要注意这个特性，因为内部实现机制不可能提供较复杂的数据结构，所以信号的接收并不是一个队列。比如说进程有一个 `SIGCHLD` 信号处于等待状态，那么之后进来的 `SIGCHLD` 信号都会被直接扔掉。

当然，进程也可以阻塞特定信号的接收，但信号的发送并不受控制，所以被阻塞的信号仍然可以被发送，不过直到进程取消阻塞该信号之后才会被接收。内核用等待(pending)位向量和阻塞(blocked)位向量来维护每个进程的信号相关状态。

`signal` 函数可以修改默认的动作，函数原型为 `handler_t *signal(int signum, handler_t *handler)`。我们通过一个简单的例子来感受下，这里我们屏蔽了 `SIGINT` 函数，即使按下 `ctrl+c` 也不会终止

```c
void sigint_handler(int sig) // SIGINT 处理器
{
    printf("想通过 ctrl+c 来关闭我？\n");
    sleep(2);
    fflush(stdout);
    sleep(1);
    printf("OK. :-)\n");
    exit(0);
}

int main()
{
    // 设定 SIGINT 处理器
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        unix_error("signal error");
        
    // 等待接收信号
    pause();
    return 0;
}
```

### 阻塞信号

我们知道，内核会阻塞与当前在处理的信号同类型的其他正待等待的信号，也就是说，一个 SIGINT 信号处理器是不能被另一个 SIGINT 信号中断的。

如果想要显式阻塞，就需要使用 `sigprocmask` 函数了，以及其他一些辅助函数：

- `sigemptyset` - 创建空集
- `sigfillset` - 把所有的信号都添加到集合中（因为信号数目不多）
- `sigaddset` - 添加指定信号到集合中
- `sigdelset` - 删除集合中的指定信号

我们可以用下面这段代码来临时阻塞特定的信号：

```
sigset_t mask, prev_mask;

Sigemptyset(&mask); // 创建空集
Sigaddset(&mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中

// 阻塞对应信号，并保存之前的集合作为备份
Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
...
... // 这部分代码不会被 SIGINT 中断
...
// 取消阻塞信号，恢复原来的状态
Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
```



### 安全处理信号

信号处理器的设计并不简单，因为它们和主程序并行且共享相同的全局数据结构，尤其要注意因为并行访问可能导致的数据损坏的问题，这里提供一些基本的指南（后面的课程会详细介绍）

- 规则 1：信号处理器越简单越好

  - 例如：设置一个全局的标记，并返回

- 规则 2：信号处理器中只调用异步且信号安全(async-signal-safe)的函数

  - 诸如 `printf`, `sprintf`, `malloc` 和 `exit` 都是不安全的！

- 规则 3：在进入和退出的时候保存和恢复

   

  ```
  errno
  ```

  - 这样信号处理器就不会覆盖原有的 `errno` 值

- 规则 4：临时阻塞所有的信号以保证对于共享数据结构的访问

  - 防止可能出现的数据损坏

- 规则 5：用

   

  ```
  volatile
  ```

   

  关键字声明全局变量

  - 这样编译器就不会把它们保存在寄存器中，保证一致性

- 规则 6：用

   

  ```
  volatile sig_atomic_t
  ```

   

  来声明全局标识符(flag)

  - 这样可以防止出现访问异常

这里提到的异步信号安全(async-signal-safety)指的是如下两类函数：

1. 所有的变量都保存在栈帧中的函数
2. 不会被信号中断的函数

## 非本地跳转 Non local Jump

所谓的本地跳转，指的是在一个程序中通过 goto 语句进行流程跳转，尽管不推荐使用goto语句，但在嵌入式系统中为了提高程序的效率，goto语句还是可以使用的。本地跳转的限制在于，我们不能从一个函数跳转到另一个函数中。如果想突破函数的限制，就要使用 `setjmp` 或 `longjmp` 来进行非本地跳转了。





































