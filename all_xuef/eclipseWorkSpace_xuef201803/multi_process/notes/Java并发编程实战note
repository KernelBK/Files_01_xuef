### 1.2 多线程的意义
1. IO阻塞时不用等待其完成，就能进行其他操作。
2. Tomcat 在收到一个客户端请求时，就另开一个线程。
《How Tomcat Works》的这部分代码很值得学习。
3. 想要更灵敏的用户界面
当进行耗时操作(如进行拼写检查，或从网络获取资源时)，可以将该耗时操作单开一个线程，这样事件线程就能
继续响应和处理界面事件了。

### 1.3 风险和挑战
1.3.1 安全性问题
线程安全性可能是非常复杂的，在没有充足同步的情况下，多个线程的操作执行顺序是不可预测的，甚至会产生奇怪的结果。

由于多个线程要共享相同的内存地址空间，并且是并发运行，因此它们可能会访问或修改其他线程正在使用的变量。
当然，这是一种极大的便利，因为这种方式比其他线程间通信机制更容易实现数据共享。
但它同样也带来了巨大风险。当多个线程同时访问和修改相同的变量时，将会在串行编程模型中引入
非串行因素，而这种非串行是很难分析的。(函数式编程提供另一种模型)


1.4 
在 Servlet 规范中， Servlet需要满足被多个线程同时调用，换句话说，需要是线程安全的。

及时你可以确保每次只有一个线程调用某个Servlet，但在构建网页应用程序时仍然必须注意线程安全性。Servlet通常
会访问与其他Servlet共享的信息，例如应用程序中的对象（这些对象保存在ServletContext中），或者
会话中的对象（这些对象保存在每个客户端的HTTPSession中）。当一个Servlet访问在多个Servlet或者请求中
共享的对象时，必须正确地协同对这些对象的访问，因为多个请求可能在不同的线程中访问这些对象。
Servlet和JSP，以及在ServletContext和HTTPSession等容器中保存的Servlet过滤器和对象等，
都必须是线程安全的。


每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。
一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；
反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。


2.1
与大多数Servlet相同，StatelessFactorizer是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。
计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。
访问StatelessFactorizer的线程不会影响另一个访问同一个StatelessFactorizer的线程的计算结果，因为这
两个线程并没有共享状态，就好像它们都在访问不同的实例。

大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。
只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。

2.2 原子性

2.2.1 静态条件(Race Condition)
最常见的竞态条件类型就是"先检查后执行"(Check then Act)操作，即通过一个可能失效的观测结果
来决定下一步的动作。
先检查后执行：首先观察到某个条件为真（如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），
但事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X），
从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）。

2.2.2 示例：延迟初始化中的竞态条件



2.3 加锁机制
缓存策略(Map)
key value 要同步更新

2.3.2 重入
But because intrinsic locks are reentrant, if a thread tries to 
acquire a lock that it already holds, the request succeeds.

2.5 活跃性与性能
由于service是一个synchronized方法，因此每次只有一个线程可以执行。这就背离了Servlet框架的
初衷，即Servlet需要能同时处理多个请求，这在负载过高的情况下将给用户带来糟糕的体验。
如果Servlet在对某个大数值进行因数分解时需要很长的执行时间，那么其他的客户端必须一直等待，直到
Servlet处理完当前的请求，才能开始另一个新的因数分解运算。
如果在系统中有多个CPU系统，那么当负载很高时，仍然会有处理器处于空闲状态。
即使一些执行时间很短的请求，比如访问缓存的值，仍然需要很长时间，因为这些请求都必须等待前一个请求执行完成。



2.3.1 内置锁
