chap8 对象的容纳
“如果一个程序只含有数量固定的对象，而且已知它们的存在时间，那么这个程序可以说是相当简单的。”

有两方面的问题将数组与其他集合类型区分开来：效率和类型。对于Java 来说，为保存和访问一系列对象
（实际是对象的句柄）数组，最有效的方法莫过于数组。

# 数组好，因为简单；数组不好，因为简单。
数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：
创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变。

在Java 中，无论使用的是数组还是集合，都会进行范围检查――若超过边界，就会
获得一个RuntimeException（运行期违例）错误。

在另一方面，由于 C++的 vector不进行范围检查，所以访问速度
较快――在 Java 中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。

本章还要学习另外几种常见的集合类：Vector（矢量）、Stack（堆栈）以及 Hashtable（散列表）。
这些类都涉及对对象的处理――好象它们没有特定的类型。换言之，它们将其当作 Object 类型处理。
从某个角度看，这种处理方法是非常合理的：我们仅需构建一个集合，然后任何Java 对象都可以进入那个集合
（除基本数据类型外――可用Java 的基本类型封装类将其作为常数置入集合，或者将其封装到自己的类内，作为可以变化的值使用）。
这再一次反映了数组优于常规集合：创建一个数组时，可令其容纳一种特定的类型。
这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。
当然，在编译期或者运行期，Java 会防止我们将不当的消息发给一个对象。
所以我们不必考虑自己的哪种做法更加危险，只要编译器能及时地指出错误，同时在运行期间加快速度，目
的也就达到了。此外，用户很少会对一次违例事件感到非常惊讶的。
考虑到执行效率和类型检查，应尽可能地采用数组。然而，当我们试图解决一个更常规的问题时，数组的局
限也可能显得非常明显。在研究过数组以后，本章剩余的部分将把重点放到Java 提供的集合类身上。