一定要追求完美!!!

AOP 面向切面编程(Aspect Oriented Programming)
## 切面
表示从业务逻辑中分离出来的横切逻辑，如性能监控、日志记录、权限控制等。
这些功能可从核心的业务逻辑代码中抽离出去。
即，通过AOP可以解决代码耦合问题，使职责更加单一。

## AspectJ(比Spring自带的aop好)
Spring + AspectJ

## 应用场景
1. 统计每个方法的执行时间

2. JDBC 数据库操作
开头: 连接数据库
...操作...
结尾: 关闭数据库连接

## Spring AOP
### 使用
1. 编程式
2. 声明式

### 5种切入
前置通知
后置通知
返回通知
异常通知
引入增强

### 我们想拦截某些类的某些方法
Advisor(切面)封装了Advice(增强)和Pointcut(切点)

---Spring AOP 的使用(基于正则表达式的切面类)
如何拦截指定注解的方法???

---Spring + AspectJ
AspectJ 切点表达式

@Aspect
public class LoggingAspect {

    @Before("execution(* com.qcc.beans.aop.*.*(..))")
    public void beforeMethod(JoinPoint jp){
        String methodName = jp.getSignature().getName();
        System.out.println("the method " + methodName + " 
        						begins with " + Arrays.asList(jp.getArgs()));
    }

    @AfterReturning(value="execution(* com.qcc.beans.aop.*.*(..))",
    			returning="result")
    public void afterReturningMethod(JoinPoint jp, Object result){
        String methodName = jp.getSignature().getName();
        System.out.println("the method " + methodName + " ends with " + 
        						result);
    }

    @After("execution(* com.qcc.beans.aop.*.*(..))")
    public void afterMethod(JoinPoint jp){
        System.out.println("this is a afterMethod advice...");
    }

    @AfterThrowing(value="execution(* com.qcc.beans.aop.*.*(..))",throwing="e")
    public void afterThorwingMethod(JoinPoint jp, NullPointerException e){
        String methodName = jp.getSignature().getName();
        System.out.println("【异常通知】the method 【" + methodName + "】 occurs exception: " + e);
    }

//  /**
//   * 环绕通知：目标方法执行前后分别执行一些代码，发生异常的时候执行另外一些代码
//   * @return 
//   */
//  @Around(value="execution(* com.qcc.beans.aop.*.*(..))")
//  public Object aroundMethod(ProceedingJoinPoint jp){
//      String methodName = jp.getSignature().getName();
//      Object result = null;
//      try {
//          System.out.println("【环绕通知中的--->前置通知】：the method 【" + methodName + "】 begins with " + Arrays.asList(jp.getArgs()));
//          //执行目标方法
//          result = jp.proceed();
//          System.out.println("【环绕通知中的--->返回通知】：the method 【" + methodName + "】 ends with " + result);
//      } catch (Throwable e) {
//          System.out.println("【环绕通知中的--->异常通知】：the method 【" + methodName + "】 occurs exception " + e);
//      }
//      
//      System.out.println("【环绕通知中的--->后置通知】：-----------------end.----------------------");
//      return result;
//  }

}











