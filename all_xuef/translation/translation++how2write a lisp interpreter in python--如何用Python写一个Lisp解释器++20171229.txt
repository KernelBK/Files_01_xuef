如何用python写一个scheme的解释器——version1
——peter norvig
原文链接：http://norvig.com/lispy.html
写在前：我基本上是翻译原文，但会省略我觉得不重要的，另外加入一些我的理解。
这个是第一版本的，因为我目前只看了第一部分，改天看完第二部分后再给出余下的内容。

norvig在本文中用尽可能少的代码很清晰的向我们说明了一个解释器的核心。
就说词法分析那部分，就一行代码，但是把意思说的清清楚楚。
我在看《Composing Programs》时，第三章也是实现一个scheme的解释器，但是他的词法分析却要复杂些，
我对着那个方法看了足足一小时，然后就困了。我觉得有点让我迷失在细节里的。

+++正文+++
本文有两个目的：讲清楚如何实现计算机语言的解释器，特别的要使用python3写一个scheme的解释器.
几年前我用别的语言写过一个半实用的scheme解释器。这一次，围绕这个目标，我要尽量简洁的表达，
如Alan Kay所称作的“软件中的麦克斯韦方程”。

为什么这个东西很重要？如Steve Yegge所说，“如果你不知道编译器如何工作，你就不可能知道计算机是
怎么工作的”。

#1. scheme程序的语法和语义（Syntax and Semantics）
一门语言的语法指的是形成正确语句和表达式（statements and expressions）的字符序列；
语义指的是这些语句和表达式的意义。比如，在数学表达式中，把1加到2的语法是"1 + 2"，其语义
是将加操作应用到两个数字上，生成结果3.我们把决定一个表达式的值叫作对表达式求值（evaluate）；
我们会说，"1 + 2" 求值到3，写作 "1 + 2" => 3.

scheme的语法与大多数语言都不同。与java对比：

******************
java有着一个很广泛的语法常用语（关键词，中缀操作，三种括号，操作符优先，点记号，引用，逗号和分号），
但是scheme的语法要简单的多：
* scheme程序仅仅由表达式构成。没有语句/表达式的区别。
* 数字（Numbers）和符号（symbols）被称作原子表达式（atomic exp），它们不能被再分解。这跟java中的
对应物一样，除了有一点，在scheme中像 + 和 > 这样的额操作符也只是符号，如A和fn一样被对待。
* 其他一切都是一个列表表达式（list exp）。以'('开始，中间一系列表达式，以')'结束。
列表的第一个元素决定它的意义：
++ 如果是一个关键词，如(if ...)，这是一个特殊形式（special form），意义依关键词而定。
++ 如果不是一个关键词，如(fn ...)，则是一个函数呼叫（调用）。（也即是说，期待fn 是一个函数）

scheme的美在于，全部语言只有5个关键词加上8个语法形式。最为对比，Python有33个关键字和110个语法
形式，Java有50个关键字和133个语法形式。scheme那么多括号看上去有点吓人，但是scheme的语法有着简洁
和一致性的优点。

本文中，我们将囊括scheme语言和它的解释器的所有重要方面（忽略一些小的细节），但是我们要分两步，
首先定义一个简单版本，然后定义一个几乎完整版本。

#2. Language 1： Lispy Calculator
Lispy Calculator是scheme的一个子集，它只使用了5个语法形式（两个原子形式，两个特殊形式，还有过程调用）。
Lispy Calculator允许你在一个典型计算器上能作的任何计算——只要你对前缀表达式习惯。你还能做些计算器不能做的：
'if'，定义变量。这里有个例子，计算半径为10的圆的面积：
(define r 10)
(* pi (* r r))

下表给出所有允许的表达式：

****************************

在语法那一列，symbol必须是symbol（符号），number必须是整数（integer）或浮点数，其他斜体词可以是
任何表达式。arg... 意思是0或多个arg

#3. 一个语言解释器要做哪些？
一个语言解释器包含两部分：
1. 解析（parsing）：解析模块接受一个以字符序列表示的输入程序，根据该语言的语法规则进行检查，
然后把程序转换为内部表示。在一个简单解释器中，程序在内部被表示成一个树结构（常被称作抽象语法树），
它是程序中语句/表达式嵌套结构的镜像。Lispy 解析器由函数parse实现。对应于编译器，它所解析的程序在内部
被表示成一个可被机器直接执行的指令序列（也是经由抽象语法树转换来的）。
2. 执行：该程序的内部表示然后会被根据语义规则执行，生成输出。Lispy的执行部分叫_eval_.

下面的图景说明了解释器的流程：
源程序 ——>[解析器] ——>抽象语法树 ——>[求值器] ——>结果

下面给出parse和_eval_的运行示例，以展示其效果（begin 依次求值每个表达式，返回最后一个表达式的值）
>> program = "(begin (define r 10) (* pi (* r r)))"

>>> parse(program)
['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]]

>>> _eval_(parse(program))
314.1592653589793

#4. 类型定义
我们先明确下scheme对象的表示：
Symbol = str              # A Scheme Symbol is implemented as a Python str
Number = (int, float)     # A Scheme Number is implemented as a Python int or float
Atom   = (Symbol, Number) # A Scheme Atom is a Symbol or Number
List   = list             # A Scheme List is implemented as a Python list
Exp    = (Atom, List)     # A Scheme expression is an Atom or List
Env    = dict             # A Scheme environment (defined below) 
								# is a mapping of {variable: value}
xuef：因为我们是用Python来写的，所以要映射到python对象。

#5. 解析：parse, tokenize and read_from_tokens
解析过程传统上分为两部分：词法分析，输入字符串被分解成符号序列（sequence of tokens），和语法分析，
符号被收集进抽象语法树。Lispy的符号有——括号，符号（symbols）和数字。有很多用于词法分析的工具（如
Mike Lesk and Eric Schmidt's lex），但是我们在这里使用一个很简单的工具：Python的 str.split.
函数tokenize接受一个字符串作为输入；它在每个括号两边添加空格，然后调用str.split以生成符号列表。


函数parse接受程序的字符串表示作为输入，调用tokenize获得符号列表，然后调用read_from_tokens以集成一个
抽象语法树。
read_from_tokens 检查第一个符号；如果是')'，语法错误。如果是'('，然后我们开始构建一个子表达时列表
直到遇到')'。任何非括号的符号（token）必须是一个符号（symbol）或数字。我们在python中对它作区分：
对于每个非括号的token，首先将其解释为int，否则解释为float，如果都不是，那它肯定是一个符号。
下面是解释器（parser）：

xuef：思考下条件语句如if的本质，无非是根据条件的不同而流向不同的分支。那么有其他结构也能实现这个目的，
如异常，字典，它们也是根据条件的不同而流向不同的分支。

看一下parse如何工作：
>>> program = "(begin (define r 10) (* pi (* r r)))"

>>> parse(program)
['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]]

xuef：何谓树？何谓抽象语法树？其实一个嵌套列表就是一棵树。

#6. 环境（Environments）
一个环境指的是变量名到其值的映射。默认情况下， _eval_使用全局环境，全局环境包含一系列标准函数
的名字（如sqrt， max， 还有操作符如 *）。用户可以使用(define symbol value) 来定义变量，它会
添加进这个环境中。

#7. 求值（Evaluation：_eval_）
我们现在要实现_eval_。

好了，我们已经完成第一版本！可以试试看：
>>> eval(parse("(begin (define r 10) (* pi (* r r)))"))
314.1592653589793

#8. 交互：读取-求值-打印 循环（Interaction: A REPL）
每次都要输入_eval_(parse("..."))是很乏味的。lisp的伟大遗产之一就是它的repl概念：程序员输入表达式，看着
它被立即读取——求值——打印，而不用经过一个冗长的构建/编译/运行的循环。
所以让我们来定义函数repl（实现read-eval-print-loop），函数schemestr将python对象转换回对应的scheme字符串。


好了，最后看一下效果：

						  

































我最近的思想收获：
人们都说python容易，这指的是什么呢？容易？某种程度上我同意。但是我又不同意。
容易指的是，python在某些领域（比较广）更容易表达你的想法，实现你的构想。
说它不容易是因为，一门语言的语法根本就是细枝末节，真正重要的是——如何解决问题？如何设计程序，
是否有独到的想法和聪明的算法，以及对世界的深刻洞察。而这些与某一门语言无关，不过语言会影响你
的思维和价值观。
人们喜欢轻松的简单的东西，因为那会让他觉得自己是行的。不过这总是一种假象。
@ 表现在学习编程上。
在练习中总是想写些应用层程序，因为那会让自己看到一些成果，漂亮的界面，绚丽的色彩。然而，
华丽的外表下实际上没什么内容。这给我提出了一个警告：学习编程就要直击那计算机的核心，那最本质的部分。
@ 表现在读书上。
一本数学书或编程书，最重要的是那些习题。然而我总是跳过，想来我追求的只是把书快速看完，以产生我读完
一本书的效果，而这只是假象。

@ 表现在对大学教育的看法上
大学时，我也讨厌学校的课程，我会骂老师平庸，会骂课程对工作无用。
其实这些都是基于一个假设，即我是正常的我是无错的，一句话——我是太阳，你们都是围着我转的小行星。
可能是没想到这一点，也可能是太残忍而不愿承认。
我最新的系统观告诉我，大学志在高等教育，然而它却做不到，即便给它一些合格的青年。而现实却是，
很多大学生并没有接受高等教育的资格，不唯思维能力上，更在心态和价值观上。
我想说的是，如果跟不上学校的课程，不能张口就怪学校，更有可能是在于你不够努力和聪明。




