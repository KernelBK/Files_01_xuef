

如何创建一个解释器或编译器这么复杂的问题，你会如何处理呢？开始的时候它很像是一团乱糟糟的毛线，
你得重新梳理展开，然后缠成一个完美的毛线球 。

达到上述目的的方法只需一次解开一根线、一个结。虽然有时候你可能会觉得你无法马上理解某些事情，
但是你必须坚持下去。我保证如果你足够坚持，最后你会“豁然开朗”。



我花费了一些时间来适应这种表示法，它是如何工作的和它与解析器、语法分析器的关系。
但是我必须告诉你，从长远来看，学习它是值得的。因为它在实际中被广泛应用，你也一定
会遇到一些编译器文献在某些时候会用到它。所以，为何不早点学呢？:)

现在，让我们将文法映射成代码。

这里是用于将文法转换成源代码的准则。遵循这些准则，你可以逐字逐句地把文法翻译给正在工作的分析器：

1. 文法中定义的每条规则，R，会变成一个同名的方法，而对那条规则的引用变成一个方法调用：R()。
方法的主体跟着同一套准则的规则的主体流。
2. 多个可选项 (a1 | a2 | aN) 变成 if-elif-else 语句。
3. 可选的 (…)* 集合变成 while 语句，该语句可以循环 0 次或者多次。
4. 每个符号引用 T 变成对 eat 方法的调用：eat(T)。eat 方法的工作方式是如果该方法匹配当前的 lookahead 符号，
那么 eat 方法会传入符号 T，然后它会从词法分析器中得到一个新的符号，并且把该符号分配给内部变量 current_token。


一段文法通过说明它可以组成什么句子来定义一种语言（language）。
这是如何使用文法推导出算术表达式：首先以开始符号 expr 开始，然后反复地用一个非终结符所在规则的
主体替代该非终结符，直到产生一个只包含终结符的句子。那些句子组成了由文法定义的语言。

如果文法不能得到一条确定的算术表达式，那么它不支持该表达式，并且当解析器尝试识别该表达式时，解析器会生成一个语法错误。

### 那些约定的好处是我们可以从一个展示算术运算符的结合律和优先级的表格中构建算术表达式的文法。
讨论这么多关于运算符的结合律和优先级，我希望你不要认为我想让你无聊死。那些约定的好处是我们可以从一个展示算术运算符的结合律
和优先级的表格中构建算术表达式的文法。然后我们可以遵循我在《一起来写个简单的解释器（4）》文章中概括的准则，将文法翻译成代码，
我们的解释器也有能力处理除了结合律之外的运算符优先级。




在表格中，运算符 + 和 – 有着相同的优先级，它们都是左结合的。你也可以看到运算符 * 和 / 也是左结合，有着相同的优先级，
但是它们的优先级比加法和减法运算符的优先级要高。

下面是如何根据优先级表格构建文法的规则：
1. 为每个优先级定义一个非终结符。非终结符所在产生式的主体应该包含同等级的算术运算符和优先级高一级的非终结符。
2. 为表达式的基数创建一个额外的非终结符系数，在我们的例子中该系数是整数。通用的规则是如果你有 N 层优先级，那么你总共
需要 N + 1 个非终结符：每层优先级需要一个非终结符，加上一个用于表达式基数的非终结符。





