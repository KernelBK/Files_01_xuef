



从上图可以看出，抽象语法树在抓住输入的本质的同时比分析树更小。

抽象语法树和分析树的区别如下：

1. 抽象语法树把操作符/操作作为根节点和中间节点，操作数作为它们的子节点。
2. 和分析树不同，抽象语法树不把语法规则表示成中间节点。
3. 抽象语法树没有把语法的每个细节都表示出来（这也是“抽象”的来历）。比如，抽象语法树里面没有规则节点和括号。
4. 对于同样的语言结构来说，抽象语法树比分析树更加紧凑。

什么是抽象语法树？抽象语法树是表示语言的抽象语法结构的一棵树，它的每个中间节点和根节点表示一个操作符，这些节点的子节点表示该操作符的操作数。


### AST 中如何表示优先级？
到目前为止还不错，但是在抽象语法树里操作符的优先级怎么表示？在抽象语法树中，要表示操作符的优先级，即“X先于Y发生”，
只要把X放在树中比Y低的位置就可以了。之前的图片中的抽象语法树就是这么做的。


### 如何构建AST

### 遍历AST
你会如何遍历这棵树，来计算它表示的表达式的值？答案是后序遍历——深度优先遍历的一种特殊形式。后序遍历从根节点开始，
从左到右递归地遍历每个节点的子节点。后序遍历尽可能快地遍历离根节点最远的节点。

下面是后续遍历的伪代码，其中«postorder actions»是操作占位符，对于BinOp节点就是加减乘除，对于Num节点就是简单地返回它的整型值。

使用后序遍历的原因是：首先，我们应该先计算树中更靠下的中间节点，因为它们代表优先级更高的操作符；
其次，在执行一个操作符的操作前，我们得先计算它的操作数的值。

完整地说，一共有3种深度优先遍历：前序遍历，中序遍历，后序遍历。它们的名字来源于遍历代码中操作的位置：

有时候你在3个位置（前序，中序，后序）都需要执行操作。


### 添加一元操作符
现在，我们要升级语法规则，来支持一元加和一元减操作符。首先先修改 factor 规则，在其中添加一元操作符。
把一元操作符加在 factor 规则里是因为它的优先级要高于二元操作符（加减乘除）。

文法
expr: term((PLUS|MINUS)term)*
term: factor((MUL|DIV)factor)*
factor: (PLUS|MINUS) | NUM | (expr)





