# 宏

Lisp 代码是由 Lisp 对象的列表来表示。2.3 节宣称这让 Lisp 可以写出**可自己写程序的程序**。本章将示范如何跨越表达式与代码的界线。



## 10.1 求值 (Eval)

如何产生表达式是很直观的：调用 `list` 即可。我们没有考虑到的是，如何使 Lisp 将列表视为代码。这之间缺少的一环是函数 `eval` ，它接受一个表达式，将其求值，然后返回它的值:

```
> (eval '(+ 1 2 3))
6
> (eval '(format t "Hello"))
Hello
NIL
```

如果这看起很熟悉的话，这是应该的。这就是我们一直交谈的那个 `eval` 。下面这个函数实现了与顶层非常相似的东西:

```
(defun our-toplevel ()
  (do ()
      (nil)
    (format t "~%> ")
    (print (eval (read)))))
```

也是因为这个原因，顶层也称为**读取─求值─打印循环** (read-eval-print loop, REPL)。

对于程序员来说， `eval` 的主要价值大概是作为 Lisp 的概念模型。我们可以想像 Lisp 是由一个长的 `cond` 表达式定义而成:

```
(defun eval (expr env)
  (cond ...
        ((eql (car expr) 'quote) (cdr expr))
        ...
        (t (apply (symbol-function (car expr))
                  (mapcar #'(lambda (x)
                              (eval x env))
                          (cdr expr))))))

```

许多表达式由预设子句 (default clause)来处理，预设子句获得 `car` 所引用的函数，将 `cdr` 所有的参数求值，并返回将前者应用至后者的结果。 [[1\]](http://acl.readthedocs.io/en/latest/zhCN/ch10-cn.html#id5)

但是像 `(quote x)` 那样的句子就不能用这样的方式来处理，因为 `quote` 就是为了防止它的参数被求值而存在的。所以我们需要给 `quote` 写一个特别的子句。这也是为什么本质上将其称为特殊操作符 (special operator): 一个需要被实现为 `eval` 的一个特殊情况的操作符。

函数 `coerce` 与 `compile` 提供了一个类似的桥梁，让你把列表转成代码。你可以 `coerce` 一个 lambda 表达式，使其成为函数，

```
> (coerce '(lambda (x) x) 'function)
#<Interpreted-Function BF9D96>

```

而如果你将 `nil` 作为第一个参数传给 `compile` ，它会编译作为第二个参数传入的 lambda 表达式。

```
> (compile nil '(lambda (x) (+ x 2)))
#<Compiled-Function BF55BE>
NIL
NIL

```

由于 `coerce` 与 `compile` 可接受列表作为参数，一个程序可以在动态执行时 (on the fly)构造新函数。但与调用 `eval` 比起来，这不是一个从根本解决的办法，并且需抱有同样的疑虑来检视这两个函数。

函数 `eval` , `coerce` 与 `compile` 的麻烦不是它们跨越了代码与列表之间的界线，而是它们在执行期做这件事。跨越界线的代价昂贵。大多数情况下，在编译期做这件事是没问题的，当你的程序执行时，几乎不用成本。下一节会示范如何办到这件事。



## 10.2 宏 (Macros)

写出能写程序的程序的最普遍方法是通过定义宏。*宏*是通过转换 (transformation)而实现的操作符。你通过说明你一个调用应该要翻译成什么，来定义一个宏。这个翻译称为宏展开(macro-expansion)，宏展开由编译器自动完成。所以宏所产生的代码，会变成程序的一个部分，就像你自己输入的程序一样。



宏通常通过调用 `defmacro` 来定义。一个 `defmacro` 看起来很像 `defun` 。但是与其定义一个函数调用应该产生的值，它定义了该怎么翻译出一个函数调用。举例来说，一个将其参数设为 `nil` 的宏可以定义成如下:

```
(defmacro nil! (x)
  (list 'setf x nil))
```

这定义了一个新的操作符，称为 `nil!` ，它接受一个参数。一个这样形式 `(nil! a)` 的调用，会在求值或编译前，被翻译成 `(setf anil)` 。所以如果我们输入 `(nil! x)` 至顶层，

```
> (nil! x)
NIL
> x
NIL
```

完全等同于输入表达式 `(setf x nil)` 。

要测试一个函数，我们调用它，但要测试一个宏，我们看它的展开式 (expansion)。

函数 `macroexpand-1` 接受一个宏调用，并产生它的展开式:

```
> (macroexpand-1 '(nil! x))
(SETF X NIL)
T

```

一个宏调用可以展开成另一个宏调用。当编译器（或顶层）遇到一个宏调用时，它持续展开它，直到不可展开为止。



## 10.3 反引号 (Backquote)

反引号读取宏 (read-macro)使得从模版 (templates)建构列表变得有可能。反引号广泛使用在宏定义中。

一个反引号单独使用时，等于普通的引号:

```
> `(a b c)
(A B C)
```

和普通引号一样，单一个反引号保护其参数被求值。

反引号的优点是，在一个反引号表达式里，你可以使用 `,` （逗号）与 `,@` （comma-at）来重启求值。如果你在反引号表达式里，在某个东西前面加逗号，则它会被求值。所以我们可以使用反引号与逗号来建构列表模版:

```
> (setf a 1 b 2)
2
> `(a is ,a and b is ,b)
(A IS 1 AND B IS 2)
```

通过使用反引号取代调用 `list` ，我们可以写出会产生出展开式的宏。举例来说 `nil!` 可以定义为:

```
(defmacro nil! (x)
  `(setf ,x nil))
```



`,@` 与逗号相似，但将（本来应该是列表的）参数扒开。将列表的元素插入模版来取代列表。

```
> (setf lst '(a b c))
(A B C)
> `(lst is ,lst)
(LST IS (A B C))
> `(its elements are ,@lst)
(ITS ELEMENTS ARE A B C)
```

`,@` 在宏里很有用，举例来说，在用剩余参数表示代码主体的宏。假设我们想要一个 `while` 宏，只要初始测试表达式为真，对其主体求值:

```
> (let ((x 0))
    (while (< x 10)
       (princ x)
       (incf x)))
0123456789
NIL

```

我们可以通过使用一个剩余参数 (rest parameter) ，搜集主体的表达式列表，来定义一个这样的宏，接着使用 comma-at 来扒开这个列表放至展开式里:

```
(defmacro while (test &rest body)
  `(do ()
       ((not ,test))
     ,@body))
```



## 10.4 示例：快速排序法(Example: Quicksort)



## 10.5 设计宏 (Macro Design)

撰写宏是一种独特的程序设计，它有着独一无二的目标与问题。能够改变编译器所看到的东西，就像是能够重写它一样。所以当你开始撰写宏时，你需要像语言设计者一样思考。

本节快速给出宏所牵涉问题的概要，以及解决它们的技巧。作为一个例子，我们会定义一个称为 `ntimes` 的宏，它接受一个数字 *n* 并对其主体求值 *n* 次。

```
> (ntimes 10
    (princ "."))
..........
NIL
```

下面是一个不正确的 `ntimes` 定义，说明了宏设计中的某些议题:

```
(defmacro ntimes (n &rest body)
  `(do ((x 0 (+ x 1)))
       ((>= x ,n))
     ,@body))
```

这个定义第一眼看起来可能没问题。在上面这个情况，它会如预期的工作。但实际上它在两个方面坏掉了。

一个宏设计者需要考虑的问题之一是，不小心引入的变量捕捉 (variable capture)。这发生在当一个在宏展开式里用到的变量，恰巧与展开式即将插入的语境里，有使用同样名字作为变量的情况。不正确的 `ntimes` 定义创造了一个变量 `x` 。所以如果这个宏在已经有 `x` 作为名字的地方被调用时，它可能无法做到我们所预期的:

```
> (let ((x 10))
    (ntimes 5
       (setf x (+ x 1)))
    x)
10
```

如果 `ntimes` 如我们预期般的执行，这个表达式应该会对 `x` 递增五次，最后返回 `15` 。但因为宏展开刚好使用 `x` 作为迭代变量， `setf`表达式递增那个 `x` ，而不是我们要递增的那个。一旦宏调用被展开，前述的展开式变成:

```
> (let ((x 10))
    (do ((x 0 (+ x 1)))
        ((>= x 5))
      (setf x (+ x 1)))
    x)
```

如果我们使用 gensym 而不是 `x` 来重写 `ntimes` 的定义，至少对于变量捕捉来说，它是安全的:

```
(defmacro ntimes (n &rest body)
  (let ((g (gensym)))
    `(do ((,g 0 (+ ,g 1)))
         ((>= ,g ,n))
       ,@body)))
```



但这个宏在另一问题上仍有疑虑: 多重求值 (multiple evaluation)。因为第一个参数被直接插入 `do` 表达式，它会在每次迭代时被求值。当第一个参数是有副作用的表达式，这个错误非常清楚地表现出来:

```
> (let ((v 10))
    (ntimes (setf v (- v 1))
      (princ ".")))
.....
NIL
```

由于 `v` 一开始是 `10` ，而 `setf` 返回其第二个参数的值，应该印出九个句点。实际上它只印出五个。

如果我们看看宏调用所展开的表达式，就可以知道为什么:

```
> (let ((v 10))
    (do ((#:g1 0 (+ #:g1 1)))
        ((>= #:g1 (setf v (- v 1))))
      (princ ".")))

```

每次迭代我们不是把迭代变量 (gensym 通常印出前面有 `#:` 的符号)与 `9` 比较，而是与每次求值时会递减的表达式比较。这如同每次我们查看地平线时，地平线都越来越近。

避免非预期的多重求值的方法是设置一个变量，在任何迭代前将其设为有疑惑的那个表达式。这通常牵扯到另一个 gensym:

避免非预期的多重求值的方法是设置一个变量，在任何迭代前将其设为有疑惑的那个表达式。这通常牵扯到另一个 gensym:

```
(defmacro ntimes (n &rest body)
  (let ((g (gensym))
        (h (gensym)))
    `(let ((,h ,n))
       (do ((,g 0 (+ ,g 1)))
           ((>= ,g ,h))
         ,@body))))

```

终于，这是一个 `ntimes` 的正确定义。

非预期的变量捕捉与多重求值是折磨宏的主要问题，但不只有这些问题而已。有经验后，要避免这样的错误与避免更熟悉的错误一样简单，比如除以零的错误。



你的 Common Lisp 实现是一个学习更多有关宏的好地方。借由调用展开至内置宏，你可以理解它们是怎么写的。下面是大多数实现对于一个 `cond` 表达式会产生的展开式:

```
> (pprint (macroexpand-1 '(cond (a b)
                                (c d e)
                                (t f))))
(IF A
    B
    (IF C
        (PROGN D E)
        F))

```

函数 `pprint` 印出像代码一样缩排的表达式，这在检视宏展开式时特别有用。



## 10.6 通用化引用 (Generalized Reference)

？？？



## 10.7 示例：实用的宏函数 (Example: Macro Utilities)

6.4 节介绍了实用函数 (utility)的概念，一种像是构造 Lisp 的通用操作符。我们可以使用宏来定义不能写作函数的实用函数。我们已经见过几个例子: `nil!` , `ntimes` 以及 `while` ，全部都需要写成宏，因为它们全都需要某种控制参数求值的方法。本节给出更多你可以使用宏写出的多种实用函数。图 10.2 挑选了几个实践中证实值得写的实用函数。

```
(defmacro for (var start stop &body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
         ((> ,var ,gstop))
       ,@body)))
```

```
> (for x 1 8
          (princ x))
12345678
NIL

```

这比写出等效的 `do` 来得省事，

```
(do ((x 1 (+ x 1)))
    ((> x 8))
  (princ x))

```

这非常接近实际的展开式:

```
(do ((x 1 (1+ x))
     (#:g1 8))
    ((> x #:g1))
  (princ x))
```

































































