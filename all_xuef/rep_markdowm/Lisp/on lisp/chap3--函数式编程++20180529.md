本章描述 Lisp 世界里较常用的一类编程方法。这些方法十分精妙，让我们能够尝试编写更有挑战的程序。
下一章将介绍一种尤其重要的编程方法，是 Lisp 让我们得以运用这种方法：即通过进化的方式开发程序，
而非遵循先计划再实现的老办法。

## 3.1 函数式设计

函数式编程意味着利用返回值而不是副作用来写程序。副作用包括破坏性修改对象 (例如通过 rplaca) 以
及变量赋值 (例如通过 setq)。如果副作用很少并且局部化，程序就会容易阅读，测试和调试。Lisp 并非从
一开始就是这种风格的，但随着时间的推移，Lisp 和函数式编程之间的关系变得越来越密不可分。

**nreverse**

**reverse**

尽管是个反派角色，bad-reverse 仍有其可取之处：它展示了 Common Lisp 交换两个值 的习惯用法。
rotatef 宏可以轮转任何普通变量的值 所谓普通变量是指那些可以作为 setf 第一个参数的变量。当
它只应用于两个参数时，效果就是交换它们。

与之相对，图 3.2 中的函数能返回顺序相反的列表。通过使用 good-reverse，我们得到的返回值是颠倒顺
序后的列表，而原始列表原封不动:

```lisp
(defun good-reverse (lst)
  (labels ((rev (lst acc)
    (if (null lst)
        acc
        (rev (cdr lst) (cons (car lst) acc)))))
      (rev lst nil)))
```

只有少数 Lisp 操作符的本意就是为了副作用。一般而言，内置操作符本来是为了调用后取返回值的。不
要被 sort、remove 或者 substitute 这样的名字所误导。如果你需要副作用，那就对返回值使用 setq。
这个规则主张某些副作用其实是难免的。坚持函数式的编程思想并没有提倡杜绝副作用。而是说除非必
要最好不要有。
养成这个习惯可能要花些时间。不妨开始时先尽量少用下列的操作符:

```lisp
set setq setf psetf psetq incf decf push pop pushnew rplaca rplacd rotatef

shiftf remf remprop remhash
```



### 需要返回多个值

在其他语言里，导致副作用的最普遍原因就是让一个函数返回多个值 的需求。如果函数只能返回一个值，
那它就不得不通过改变参数来 “返回” 其余的值。幸运的是，在 Common Lisp 里不必这样做，因为任何函数
都可以返回多值。

```lisp
> (multiple-value-bind (int frac) (truncate 26.21875)
	(list int frac))
(26 0.21875)
```

## 3.2 内外颠倒的命令式

编写函数式程序代码，你要表达你想要什么；而编写命令式程序，需要告诉它你要做什么，它是琐碎的。

函数式程序代码的用意和那些更常见的方法，即命令式程序相比可能显得更加明确一些。函数式程序告诉
你它想要什么; 而命令式程序告诉你它要做什么。函数式程序说 “返回一个由 a 和 x 的第一个元素的平方
所组成的列表:”

```lisp
(defun fun (x)
	(list ’a (expt (car x) 2)))
```

而命令式程序则会说 “取得 x 的第一个元素，把它平方，然后返回由 a 及其平方组成的列表”:

```lisp
(defun imp (x)
  (let (y sqr)
    (setq y (car x))
    (setq sqr (expt y 2))
    (list ’a sqr)))
```

Lisp 程序员有幸可以同时用这两种方式来写程序。某些语言只适合于命令式编程 尤其是 Basic，以及
大多数机器语言。事实上，imp 的定义和多数 Lisp 编译器从 fun 生成的机器语言代码在形式上很相似。

既然编译器能为你做，为什么还要自己写这样的代码呢？对于许多程序员来说，他们甚至从没想过这个问
题。语言给我们的思想打上烙印：一些习惯于命令式语言编程的人或许已经开始用命令式的术语思考问
题，而且会觉得写命令式程序比写函数式程序更容易。如果有一种语言可以助你一臂之力，这种思维定势
是值得克服的。

对于其他语言的同行来说，刚开始使用 Lisp 可能像初次踏入溜冰场那样。事实上在冰上比在干地面上更
容易行走 如果使用溜冰鞋的话。然后你对这项运动的看法就会彻底改观。
溜冰鞋对于冰的意义，和函数式编程对 Lisp 的意义是一样的。这两样东西在一起让你更优雅地移动，事半
功倍。但如果你已经习惯于另一种行走模式，那么开始的时候你就无法体会到这一点。把 Lisp 作为第二
语言学习的一个障碍就是学会如何用函数式的风格来编程。

## 3.3 函数式接口

某些副作用比其他的更糟糕。例如，尽管下面的函数调用了 nconc

```lisp
(defun qualify (expr)
	(nconc (copy-list expr) (list ’maybe)))
```

但它没有破坏引用透明。? 如果你每次都传给它一个确定的参数，那它的返回值将总是相同 (equal) 的。
从调用者的角度来看，qualify 就和纯函数型代码一样。但我们不能对 bad-reverse (第 19 页) 下同样的
评语，这个函数事实上修改了它的参数。
如果不把所有副作用的有害程度都划上等号，而是有方法能把这些情况分出个高下，那样将会对我们有很
大的帮助。可以非正式地说，如果一个函数修改的是其他函数都不拥有的东西，那么它就是无害的。例如，
qualify 里的 nconc 就是无害的，因为作为第一个参数的列表是新生成的。它不属于任何其他函数。

通常，在我们提到拥有者关系时，不能说变量的拥有者是某某函数，而应该说其拥有者是函数的某个调用。
尽管这里并没有其他函数拥有变量 x，

```lisp
(let ((x 0))
	(defun total (y)
		(incf x y)))
```

但一次调用的效果会在接下来的调用中看到。所以规则应当是：一个给定的调用 (invocation) 可以安全地
修改它唯一拥有的东西。
究竟谁是参数和返回值的拥有者? 依照 Lisp 的习惯，是函数的调用拥有那些作为返回值得到的对象，但它
并不拥有那些作为参数传给它的对象。凡是修改参数的函数都应该打上 “破坏性” 的标签，以示区别，但如
果函数修改的只是返回给它们的对象，那我们没有准备什么特别的称号给这些函数。

要想写出真正意义上的函数式代码，还要再加个条件。函数不能和不遵守这些规则的代码共享对象。例
如，尽管这个函数没有副作用，

```lisp
(defun anything (x)
	(+ x *anything*))
```

但它的返回值依赖于全局变量 *anything*。因此，如果任何其他函数可以改变这个变量的值，那
么 anything 就可能返回任意值。

要是把代码写成让每次调用都只修改它自己拥有的东西的话，那这样的代码就基本上就可以和纯函数式代
码媲美了。从外界看来，一个满足上述所有条件的函数至少会拥有有函数式的接口：如果用同一参数调用
它两次，你应当会得到同样的结果。正如下一章所展示的那样，这也是自底向上程序设计最重要的组成部
分。

破坏性的操作符还有个问题，就是它和全局变量一样会破坏程序的局部性。当你写函数式代码时，可以集
中精力：只要考虑调用正在编写的函数的调用方，或者被调用方就行了。要是你想要破坏性地修改某些数
据，这个好处就不复存在了。你修改的数据可能在任何一个地方用到。

推论之一是函数不该返回任何不能安全修改的东西。如此说来，就应当避免写那些返回包含引用对象的函
数。

??????

## 3.4 交互式编程

前一章说明了函数式的编程风格是一种组织程序的好办法。但它的好处还不止于此。Lisp 程序员并非完
全是从美感出发才采纳函数式风格的。他们采用这种风格是因为它让工作更轻松。在 Lisp 的动态环境里，
函数式程序能以非同寻常的速度写就，与此同时，写出的程序也非同寻常的可靠。

在 Lisp 里调试程序相对简单。很多信息在运行期是可见的，可以帮助追查错误的根源。但更重要的是你
可以轻易地测试程序。你不需要编译一个程序然后一次性测试所有东西。你可以在 toplevel 循环里通过逐
个地调用每个函数来测试它们。

增量测试非常有用，为了更好地利用它，Lisp 风格也随之改进。用函数式风格写出的程序可以逐个函数地
理解它，从读者的观点来看，这是它的主要优点。此外，函数式风格也极其适合增量测试：以这种风格写出
的程序可以逐个函数地进行测试。当一个函数既不检查也不改变外部状态时，任何 bug 都会立即现形。这
样，函数影响外面世界的唯一渠道是它的返回值。只要返回值是你期望的，你就完全可以信任返回它的代
码。

事实上有经验的 Lisp 程序员会尽量让他们的程序易于测试:

1. 他们试图把副作用分离到个别函数里，以便程序中更多的部分可以写成纯函数式风格。

2. 如果一个函数必须产生副作用，他们至少会想办法给它设计一个函数式的接口。

3. 他们给每个函数赋予一个单一的，定义良好的功能。

  一旦函数按照这种办法写成，程序员们就可以用一组有代表性的情况对它测试，测试好了，就使用另一组情

  况测试。如果每一块砖都各司其职，那么围墙就会屹立不倒。

在 Lisp 中，开发软件就像是面对面的交流。你可以边写代码边做测试。和对话相似，即时的回应对于开发来说一样有戏剧化的效果。你不只是把原先的程序写得更快，而是会写出另一种程序。
这是什么道理? 当测试更便捷时，你就可以更频繁地进行测试。对于 Lisp，和其他语言一样，开发是由编码
和测试构成的循环往复的周期性过程。但在 Lisp 的周期更短：单个函数，甚至函数的一部分都可以成为一
个开发周期。并且如果一边写代码一边测试的话，当错误发生时你就知道该检查哪里：应该看看最后写的
那部分。正如听起来那样简单，这一原则极大地提高了自底向上编程的可行性。它带来了额外的信赖感，
使得 Lisp 程序员至少在一定程度上从旧式的计划 –实现的软件开发风格中解脱了出来。





























