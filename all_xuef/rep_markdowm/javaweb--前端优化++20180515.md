# 资源合并与压缩

## 浏览器的一个请求从发送到返回都经历了什么？

浏览器渲染（render）---dom树+css树

**[基于现有业务]深入理解http请求的过程是前端性能优化的核心**



### dns访问优化

1. 缓存

dns是否可以通过缓存减少dns查询时间？

### 网络请求优化（网络的选择以及缓存的问题）

1. cdn（请求静态资源用的）

cdn域名不要和主站域名一样，否则还要携带主站cookie值，造成无畏的损耗。

网络请求的过程走最近的网络环境？

2. 对一些接口（在浏览器端做一些缓存策略）

相同的静态资源是否可以缓存？

3. 带宽（减小http请求的大小，与带宽一致）



4. 多次http请求合并，减少网络损耗



5. 浏览器端渲染（一些模板框架都是在浏览器端渲染的）

实际生产环境，在服务器端进行html的渲染。

6. 针对具体业务中的请求场景来做一些优化。

## 如何进行html压缩

### nodejs提供了html-minifier工具



### 后端模板引擎渲染压缩



## css压缩

#### 无效代码删除



## js压缩与混乱



## 文件合并



### 文件合并存在的问题

1. 首屏渲染的问题



2. 缓存失效问题

### 实践中

1. 公共库合并



2. 不同页面的合并



3. 随机应变



#### 语义合并







# 图片相关的优化



# css和js的装载与执行

### 目标

1. 理解浏览器端 html，css，js 的加载过程
2. 结合Chrome的能力学习掌握 css，js 加载过程中的优化点
3. 通过案例分析和实战演练深入理解学习的优化点

### 核心问题：一个页面在浏览器端是如何进行渲染的？

#### HTML 渲染过程的一些特点

1. 顺序执行，并发加载
2. 是否阻塞
3. 依赖关系

css应该在head中引入

4. 引入方式

现代生产环境中，js不可能在请求首页时一下全加载，而是路由到哪个部分需要哪个js再异步加载该js。

#### css阻塞

1. css head中阻塞页面的渲染
2.  css阻塞js的执行

这是合理的。因为js中代码可能需要依赖css中设定的样式。我们经常会基于标签的class属性来做判断条件，决定是否执行某些动作。

3. css不阻塞外部脚本的加载

#### js阻塞

1. 直接引入的js阻塞页面的渲染
2. js 不阻塞资源的加载
3. js顺序执行，阻塞后续js逻辑的执行

浏览器引擎 执行js，单线程的



# 懒加载与预加载



# 重绘与回流



# 浏览器存储



# 缓存



# 服务端性能优化

