
#开发一个关于函数是如何被应用的心智模型

"""
在前面的章节里多次谈到，可以使用一个表达式去代换一个变量。在这部分的内容里，
我们也会看到这种替换能力：计算过程需要多次对表达式进行重写，并将变量替换为表达式，
直到产生最终结果为止。
"""

##惰性求值
"""
先从一个简单的、非递归例子开始，其中 mod 函数是典型的取模函数：
-- file: ch02/isOdd.hs
isOdd n = mod n 2 == 1
"""
#第一个任务是，弄清楚 isOdd (1 + 2) 的结果是如何求值出的。
"""
在使用严格求值的语言里，函数的参数总是在应用函数之前被求值。
以 isOdd 为例子：子表达式 (1 + 2) 会首先被求值，得出结果 3 。
接着，将 3 绑定到变量 n ，应用到函数 isOdd 。
最后， mod 3 2 返回 1 ，而 1 == 1 返回 True 。
"""

"""
Haskell 使用了另外一种求值方式 —— 非严格求值。在这种情况下，求值 isOdd (1 + 2)
并不会即刻使得子表达式 1 + 2 被求值为 3 ，相反，编译器做出了一个“承诺”，
说，“当真正有需要的时候，我有办法计算出 isOdd (1 + 2) 的值”。
"""








