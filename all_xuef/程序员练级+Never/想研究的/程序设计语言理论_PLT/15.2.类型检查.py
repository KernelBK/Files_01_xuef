
#既然已经确定了语言中项和类型的结构，接下来我们来确定语言中哪些算是类型错误
#
#
##关于类型检查器的签名，初步设想，它可以接受表达式作为参数，返回布尔值指明该表达式
##是否通过检查。由于我们知道表达式中包含标识符，所以很显然我们还需要一个类型环境，
##它将名字映射到类型，类似于我们之前用到的值环境。
"""
下面来处理函数调用。我们应该首先检查函数位置，确定它是个函数，然后确保实际参数的
类型和该函数定义时声明的形式参数类型相同。


"""
##我们应该增强 tc  的归纳不变量：即，不仅仅返回表达式是否能通过类型检查，而是返回表达式的类型。
##事实上，只要有返回值，就说明该表达式通过了类型检查；否则它会抛出错误。

##从（此静态类型语言）类型检查的角度来说，加法和乘法没有区别。
##更甚，任意接受两个数作为参数返回一个数的函数都没有区别。
"""
<tc-plusC-case> ::=
[plusC (l r) (let ([lt (tc l tenv)]
                   [rt (tc r tenv)])
               (if (and (equal? lt (numT))
                        (equal? rt (numT)))
                   (numT)
                   (error 'tc "+ not both numbers")))]

"""

#函数调用和函数
"""
最后还剩下两个难一点的情形：函数调用和函数。我们已经讨论过怎么处理函数调用：计算
函数以及参数表达式的值；确保函数表达式为函数类型；检查参数类型和函数形参类型相
容。如果这些条件满足，函数调用得到的结果类型就是函数体的类型（因为运行时最终的返
回值就是计算函数体得到的值）。


<tc-appC-case> ::=
[appC (f a) (let ([ft (tc f tenv)]
                  [at (tc a tenv)])
              (cond
                [(not (funT? ft))
                 (error 'tc "not a function")]
                [(not (equal? (funT-arg ft) at))
                 (error 'tc "app arg mismatch")]
                [else (funT-ret ft)]))]

最后还剩下函数定义。函数有一个形参，函数体中一般会用到；除非它被绑定到环境中，不
然函数体应该不太可能通过类型检查。因此我们需要扩展类型环境，添加形参与其类型的绑
定，然后在扩展后的环境中检查函数体。最终计算得到的函数体类型必须和函数定义中指定
的函数返回值类型相同。如果满足了这些，该函数的类型就是指定参数类型到函数体类型的
函数。

注意到解释器与类型检查器另一个有趣的不同点。解释器中，函数调用负责计算参数表达式
的值，扩展环境，然后对函数体求值。而这里，函数调用的情形中的确也检查了参数表达
式，但是没有涉及到环境的处理，直接返回了函数体的类型，而没有遍历它。对函数体的遍
历检查过程实际是在检查函数定义的过程中进行的，因此环境也是在这个地方才实际被扩展
的。
"""


#15.2.2 条件语句的类型检查
"""
考虑为上面的语言添加条件语句，即使最简单的 if 表达式都会引入若干设计抉择。这里我们
先讨论其中的两个，后面会回过头讨论其中的一个。
1. 条件表达式的类型应该是什么？某些语言中它必须计算得到布尔值，这种情况下需要为
我们的语言添加布尔值类型（这可能是个好主意）。其它语言中，它可以是任意值，某
些值被认为是“真值”，其它的则被视为“假值”。
2.  then-  和 else-  两个分支之间的关系应该是什么呢？一些语言中它们的类型必须相同，
因此整个 if 表达式有一个确定无歧义的类型。其它语言中，两个分支可以有不同的类
型，这极大地改变了静态类型语言的设计和它的类型检查器，而且也改变了编程语言本
身的性质。
"""

#15.2.4.1 递归数据类型定义
"""
当我们说允许程序员创建递归数据时，我们实际在同时谈论三种东西：
1. 创建新的类型
2. 让新类型的实例拥有一个或多个字段
3. 让这些字段中的某些指向同类型的实例
"""

#15.2.4.3 模式匹配和去语法糖


























