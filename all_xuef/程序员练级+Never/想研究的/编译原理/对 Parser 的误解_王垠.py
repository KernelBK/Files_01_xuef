#http://www.yinwang.org/blog-cn/2015/09/19/parser

#EOPL用了解释器而不是形式语义，算是EOPL的特色。
#EOPL是一本优秀的程序语言书籍，但不是典型的，因为它没有用太多数理逻辑。
典型的书籍像Programming Languages and Lambda Calculi
#what's parser?

首先来科普一下。所谓parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。
最常见的parser，是把程序文本转换成编译器内部的一种叫做“抽象语法树”（AST）的数据结构。
也有简单一些的parser，用于处理CSV，JSON，XML之类的格式。

举个例子，一个处理算数表达式的parser，可以把“1+2”这样的，含有1，+，2三个字符的字符串，
转换成一个对象（object）。这个对象就像new BinaryExpression(ADD, new Number(1), new Number(2))
这样的Java构造函数调用生成出来的那样。

之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。
实际上，代码的本质根本就不是字符串，它本来就是一个具有复杂拓扑的数据结构，就像电路一样。
“1+2”这个字符串只是对这种数据结构的一种“编码”，就像ZIP或者JPEG只是对它们压缩的数据的编码一样。

这种编码可以方便你把代码存到磁盘上，方便你用文本编辑器来修改它们，然而你必须知道，文本并不是代码本身。
所以从磁盘读取了文本之后，你必须先“解码”，才能方便地操作代码的数据结构。
比如，如果上面的Java代码生成的AST节点叫node，你就可以用node.operator来访问ADD，
用node.left来访问1，node.right来访问2。这是很方便的。

对于程序语言，这种解码的动作就叫做parsing，用于解码的那段代码就叫做parser。



#Parser在编译器中的地位
显然，parser是必不可少的，然而它并不像很多人想象的那么重要。
Parser的重要性和技术难度，被很多人严重的夸大了。

一些人提到“编译器”，就跟你提LEX，YACC，ANTLR等用于构造parser的工具，
仿佛编译器跟parser是等价的似的。还有些人，只要听说别人写了个parser，
就觉得这人编程水平很高，开始膜拜了。这些其实都显示出人的肤浅。


我喜欢把parser称为“万里长征的第0步”，因为等你parse完毕得到了AST，真正精华的编译技术才算开始。
一个先进的编译器包含许多的步骤：语义分析，类型检查/推导，代码优化，机器代码生成，……
这每个步骤都是在对某种中间数据结构（比如AST）进行分析或者转化，它们完全不需要知道代码的字符串形式。
也就是说，一旦代码通过了parser，在后面的编译过程里，你就可以完全忘记parser的存在。
所以parser对于编译器的地位，其实就像ZIP之于JVM，就像JPEG之于PhotoShop。
Parser虽然必不可少，然而它比起编译器里面最重要的过程，是处于一种辅助性，工具性，次要的地位。


鉴于这个原因，好一点的大学里的程序语言（PL）课程，都完全没有关于parser的内容。
学生们往往直接用Scheme这样代码数据同形的语言，或者直接使用AST数据结构来构造程序。
在Kent Dybvig这样编译器大师的课程上，学生直接跳过parser的构造，开始学习最精华的语义转换和优化技术。
实际上，Kent Dybvig根本不认为parser算是编译器的一部分。
因为AST数据结构其实才是程序本身，而程序的文本只是这种数据结构的一种编码形式。


#Parser技术发展的误区
既然parser在编译器中处于次要的地位，可是为什么还有人花那么大功夫研究各种炫酷的parser技术呢。
LL，LR，GLR，LEX, YACC，Bison，parser combinator，ANTLR，PEG，……
制造parser的工具似乎层出不穷，每出现一个新的工具都号称可以处理更加复杂的语法。

很多人盲目地设计复杂的语法，然后用越来越复杂的parser技术去parse它们，
这就是parser技术仍然在发展的原因。
其实，向往复杂的语法，是程序语言领域流传非常广，危害非常大的错误倾向。
在人类历史的长河中，留下了许多难以磨灭的历史性糟粕，它们固化了人类对于语言设计的理念。
很多人设计语言似乎不是为了拿来好用的，而是为了让用它的人迷惑或者害怕。


制造这样复杂难懂的语法，其实没有什么真正的好处。不但给程序员的学习造成了不必要的困难，
让代码难以理解，而且也给parser的作者带来了严重的挑战。可是有些人就是喜欢制造问题，
就像一句玩笑话说的：有困难要上，没有困难，制造困难也要上！

如果你的语言语法很简单（像Scheme那样），你是不需要任何高深的parser理论的。
说白了，你只需要知道如何parse匹配的括号。
最多一个小时，几百行Java代码，我就能写出一个Scheme的parser。

可是很多人总是嫌问题不够有难度，于是他们不停地制造更加复杂的语法，甚至会故意让自己的
语言看起来跟其它的不一样，以示“创新”。当然了，这样的语言就得用更加复杂的parser技术，
这正好让那些喜欢折腾复杂parser技术的人洋洋得意。


#编译原理课程的误导
程序员们对于parser的误解，很大程度上来自于大学编译原理课程照本宣科的教育。
很多老师自己都不理解编译器的精髓，所以就只有按部就班的讲一些“死知识”，灌输“业界做法”。

由于parser占据了大量时间，以至于很多真正精华的内容都被一笔带过：语义分析，代码优化，
类型推导，静态检查，机器代码生成，…… 以至于很多人上完了编译原理课程，记忆中只留下写parser的痛苦回忆。


如果你想真的深入理解编译理论，最好是从PL课程的读物，比如 EOPL 开始。我可以说 PL 这个领域，
真的和编译器的领域很不一样。
理解了 PL 的理论，编译器的东西只不过是把一种语言转换成另外一种语言（机器语言）而已。
工程的细枝末节很麻烦，可是当你掌握了精髓的原理，那些都容易摸索出来。

#我写parser的心得和秘诀
很多人都觉得写parser很难，一方面是由于语言设计的错误思想导致了复杂的语法，
另外一方面是由于人们对于parser构造过程的思维误区。很多人不理解parser的本质和真正的用途，
所以他们总是试图让parser干一些它们本来不应该干的事情，或者对parser有一些不切实际的标准。


1. 现在的趋势是越来越多的语言在标准库里提供可以parse它自己的parser，比如Python和Ruby。
这样你就可以用那语言写一小段代码调用标准的parser，然后把它转换成一种常用的数据交换格式，比如JSON。
然后你就可以用通用的JSON parser解析出你想要的数据结构了。

如果你直接使用别人的parser，最好不要使用它原来的数据结构。因为一旦parser的作者在新版本改变了
他的数据结构，你所有的代码都会需要修改。
我的秘诀是做一个“AST转换器”，先把别人的AST结构转换成自己的AST结构，然后在自己的AST结构之上
写其它的代码，这样如果别人的parser修改了，你可以只改动AST转换器，其它的代码基本不需要修改。

用别人的parser也会有一些小麻烦。比如Python之类语言自带的parser，丢掉了很多我需要的信息，
比如函数名的位置，等等。我需要进行一些hack，找回我需要的数据。
相对来说，这样小的修补还是比从头写一个parser要划得来。
但是如果你实在找不到一个好的parser，那就只好自己写一个。

2. 很多人写parser，很在乎所谓的“one-pass parser”。他们试图扫描一遍代码文本就构造出最终的AST结构。
可是其实如果你放松这个条件，允许用多pass的parser，就会容易很多。你可以在第一遍用很容易的办法构造
一个粗略的树结构，然后再写一个递归树遍历过程，把某些在第一遍的时候没法确定的结构进行小规模的转换，
最后得到正确的AST。

想要一遍就parse出最终的AST，可以说是一种过早优化（premature optimization）。
有些人盲目地认为只扫描一遍代码，会比扫描两遍要快一些。然而由于你必须在这一遍扫描里进行多度复杂的操作，
最终的性能也许还不如很快的扫完第一遍，然后再很快的遍历转换由此生成的树结构。

3. 另外一些人试图在parse的过程中做一些本来不属于它做的事情，比如进行一些基本的语义检查。
有些人会让parser检查“使用未定义的变量”等语义错误，一旦发现就在当时报错，终止。
这种做法其实混淆了parser的作用，造成了不必要的复杂性。

就像我说的，parser其实只是一个解码器。parser要做的事情，应该是从无结构的字符串里面，
解码产生有结构的数据结构。而像“使用未定义的变量”这样的语义检查，应该是在生成了AST之后，
使用单独的树遍历来进行的。人们常常混淆“解码”，“语法”和“语义”三者的不同，导致他们写出
过度复杂，效率低下，难以维护的parser。

4. 所以如果你真的要写parser，我建议你直接用某种程序语言手写代码，使用普通的递归下降
（recursive descent）写法，或者parser combinator的写法。
只有手写的parser才可以方便的debug，而且可以输出清晰，人类可理解的出错信息。


Recursive descent和parser combinator写出来的parser其实可以非常强大，甚至可以超越
所谓“上下文无关文法”，因为在递归函数里面你可以做几乎任意的事情，所以你甚至可以把上下文传递
到递归函数里，然后根据上下文来决定对当前的节点做什么事情。而且由于代码可以得到很多的上下文信息，
如果输入的代码有语法错误，你可以根据这些信息生成非常人性化的出错信息。
























