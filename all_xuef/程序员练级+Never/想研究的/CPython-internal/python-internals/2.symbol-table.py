
##There are three different directions we can pursue on our path
##to deeper understanding of Python:
"""
1. Figure out the exact semantics of variables in Python - when are they local,
when are they global and what exactly makes them lexically bound.

2. Understand how the CPython compiler knows the difference.
    (2) we need to understand how CPython uses symbol tables
3. Learn about the different bytecode opcodes for these variables and how they affect
the way the VM runs code.
"""

##符号表何时被创建?
"""
Symbol tables are created in step 3. The compiler builds a symbol table from the
AST representing the Python source code. This symbol table, in conjunction with the
AST is then used to generate the control flow graph (CFG) and ultimately the bytecode.
"""

##Exploring the symbol table
"""
symtable module

Symbol tables are generated by the compiler from AST just before bytecode is generated.
The symbol table is responsible for calculating the scope of every identifier in the code.
symtable provides an interface to examine these tables.

"""



def describe_symbol(sym):
    assert type(sym) == symtable.Symbol
    print("Symbol:", sym.get_name())

    for prop in [
            'referenced', 'imported', 'parameter',
            'global', 'declared_global', 'local',
            'free', 'assigned', 'namespace']:
        if getattr(sym, 'is_' + prop)():
            print('    is', prop)

import symtable

sc = """
def outer(aa):
    def inner():
        bb = 1
        return aa + bb + cc
    return inner
"""
sym = symtable.symtable(sc,'<string>','exec')
print(dir(sym))
print('-'*20)
print(sym.get_children())













