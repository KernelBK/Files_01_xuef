
tcp 是全双工的, 不仅有发通道还有接收通道。（关闭时，两个通道都得关闭）

client							server
		
		---------syn 11---------->
		
		<-----ack 12 & syn 88-----
		
		---------ack 89---------->

===> 至此连接建立

挥手告别时:		
client.close()  (客户端关闭发送)
	（底层会发送一个数据包）客户端告诉服务端，我不会再发送数据给你了。
	服务端收到该数据包后，会向客户端发送一个应答包。接着 server_socket.recv(1024) 会解阻塞。(服务端关闭接收)
	然后调用 server_socket.close() (服务端关闭发送)
	
	client_socket.recv(1024) 会解阻塞 (客户端关闭接收)
	

??? 如何知道应答包被接收到了呢?

谁先调用 close(), 谁的资源要等待2 minute(2 MSL)再释放。(超时时间=2倍的包在网络中的最长传输时间)

这也是，如果主动关闭服务器后又马上开启服务器会报 Address already in use 的错误。因为要等待2分钟后才能释放资源。
所以，一般都是让客户端先调用 close().

那为什么客户端先 close就没问题? 因为服务端是固定端口，而客户端是动态端口。