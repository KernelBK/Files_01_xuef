
"""
为了高效处理网络 I/O，需要使用并发，因为网络有很高的延迟，所以
为了不浪费 CPU 周期去等待，最好在收到网络响应之前做些其他的事。

为了通过代码说明这一点，我写了三个示例程序，从网上下载 20 个国家的国旗图像。
第一个示例程序 flags.py 是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下一个图像。
另外两个脚本是并发下载的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。
flags_threadpool.py 脚本使用 concurrent.futures 模块，而flags_asyncio.py 脚本使用 asyncio 包。
"""
#数据通过网络到达内存?(socket 读就绪),而后需要将内存中数据复制到硬盘?
import timeit
def sam():
    sum(range(1, 1000))

print(timeit.timeit(sam,number=1000))


"""
标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回
结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线
程，而 I/O 密集型 Python 程序能从中受益：一个 Python 线程等待网络响
应时，阻塞型 I/O 函数会释放 GIL，再运行一个线程。
"""
