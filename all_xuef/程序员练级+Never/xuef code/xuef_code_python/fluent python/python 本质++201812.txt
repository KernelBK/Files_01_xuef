
lambda 句法只是语法糖：与 def 语句一样，lambda 表达式会创建函数对象。


sum 和 reduce 的通用思想是把某个操作连续应用到序列的元素上，累
计之前的结果，把一系列值归约成一个值。


## python中几类重要对象

可迭代(iterable)
可调用(callable)
	类
　　调用类时会运行类的 __new__ 方法创建一个实例，然后运行
	__init__ 方法，初始化实例，最后把实例返回给调用方。
	
	实现__call__方法的一般对象(类的实例) 
	
可修改(mutable)


## 闭包--创建保有内部状态的函数。
闭包 or 实现了__call__的类

## 运行时自省
__doc__
__dict__

函数专有的属性
sorted(set(dir(func)) - set(dir(obj)))

__annotations__ 	dict 	参数和返回值的注解
__call__					实现  () 运算符；即可调用对象协议
__closure__ tuple 			函数闭包，即自由变量的绑定（通常是  None ）
__code__ code 编译成字节码的函数元数据和函数定义体
__defaults__ tuple 形式参数的默认值

__get__ 	实现只读描述符协议（参见第 20 章）
__globals__ dict	函数所在模块中的全局变量
__kwdefaults__ dict 仅限关键字形式参数的默认值
__name__ str 函数名称
__qualname__ str	函数的限定名称，如  Random.choice 



## 词法作用域
如今，词法作用域已成常态：根据定义函数的环境计算自由变量。
词法作用域让人更难实现支持一等函数的语言，因为需要支持闭
包。不过，词法作用域让代码更易于阅读。Algol 之后出现的语言
大都使用词法作用域。



## is 与 ==

is 运算符比 == 速度快，因为它不能重载，所以 Python 不用寻找并调用
特殊方法，而是直接比较两个整数 ID。而 a == b 是语法糖，等同于
a.__eq__(b)。继承自 object 的 __eq__ 方法比较两个对象的 ID，结
果与 is 一样。但是多数内置类型使用更有意义的方式覆盖了 __eq__
方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例
如，比较大型集合或嵌套层级深的结构时。








