#R2 Spec
"""
R2 比起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。
再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有5种不同的构造。
用 Scheme 的语法，这5种构造看起来就像这样：
    变量：x
    函数：(lambda (x) e)
    绑定：(let ([x e1]) e2)
    调用：(e1 e2)
    算术：(• e2 e2)
    （其中，• 是一个算术操作符，可以选择 +, -, *, / 其中之一）

一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。
最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素。
"""
##需要注意的是，跟一般语言不同，我们的函数只接受一个参数。(直指核心，去除一切冗余干扰。专注本质)
##这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓"first-class function"。
##所以你可以用嵌套的函数定义来表示有两个以上参数的函数。(currying?)

#(((lambda (x) (lambda (y) (+ x y))) 1) 2)
#res = (lambda x: (lambda y: (x + y)))(1)(2)
#print(res)
##看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。

"""
另外，我们的绑定语法 (let ([x e1]) e2)，比起 Scheme 的绑定也有一些局限。
我们的 let 只能绑定一个变量，而 Scheme 可以绑定多个，像这样 (let ([x 1] [y 2]) (+ x y))。
这也不是一个严重的限制，因为我们可以啰嗦一点，用嵌套的 let 绑定:
(let ([x 1])
  (let ([y 2])
    (+ x y)))
"""

##我们用环境记录变量的值，并且把它们传递到变量的“可见区域”。
##变量的可见区域，用术语说叫做“作用域”（scope）。
"""
我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性。

环境其实是一个堆栈（stack）。内层的绑定，会出现在环境的最上面，这就是在“压栈”。
这样我们查找变量的时候，会优先找到最内层定义的变量。

举个例子：
(let ([x 1])         ; env='()。绑定x到1。
  (let ([y 2])       ; env='((x . 1))。绑定y到2。
    (let ([x 3])     ; env='((y . 2) (x . 1))。绑定x到3。
      (+ x y))))     ; env='((x . 3) (y . 2) (x . 1))。查找x，得到3；查找y，得到2。
;; => 5


这并不等于说 (x . 1) 就可以被改写或者丢弃，因为它仍然是有用的。
你只需要看一个稍微不同的例子，就知道这是怎么回事：

(let ([x 1])          ; env='()。绑定x到1。
  (+ (let ([x 2])     ; env='((x . 1))。绑定x到2。
       x)             ; env='((x . 2) (x . 1))。查找x，得到2。
   x))                ; env='((x . 1))。查找x，得到1。
;; => 3               ; 两个不同的x的和，1+2等于3。
"""


#Lexical Scoping 和 Dynamic Scoping
##下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于
##函数体内也许会含有外层的变量，叫做“自由变量”。
##所以在分析函数的代码之前，我们来了解一下不同的“作用域”（scoping）规则。
"""
我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？

(let ([x 2])
  (let ([f (lambda (y) (* x y))])
    (let ([x 4])
      (f 3))))
"""
#这个例子真是恰到好处!!!



['let', [
            [[['x', [1]], ['y', [2]]]],
            ['+', ['x', 'y']]
        ]
 ]






















