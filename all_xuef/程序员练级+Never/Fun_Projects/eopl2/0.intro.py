
#why learn?
"""
If you are a programmer, mastering the idea of an interpreter is a source of great power.
It provokes a real shift in mindset, a basic change in the way you think about programming.

If you don't understand interpreters, you can still write programs;
you can even be a competent programmer. But you can't be a master.

"""
#This is not an easy book.
"""
In designing an application program, you think about the specific tasks to be performed,
and consider what features to include.
But in designing a language, you consider the various applications people might want to implement,
and the ways in which they might implement them.
Should your language have static or dynamic scope, or a mixture?
Should it have inheritance?
Should it pass parameters by reference or by value?
Should continuations be explicit or implicit?
It all depends on how you expect your language to be used,
on which kinds of programs should be easy to write,
and which you can afford to make more difficult.
"""

#how2learn?
"""
So study these programs. Better yet, run them—this is working code.
Try interpreting some simple expressions, then more complex ones.
Add error messages. Modify the interpreters. Design your own variations.
Try to really master these programs, not just get a vague feeling for how they work.

If you do this, you will change your view of your programming,
and your view of yourself as a programmer.
You'll come to see yourself as a designer of languages rather than only a user of languages,
as a person who chooses the rules by which languages are put together,
rather than only a follower of rules that other people have chosen.
"""

#前置知识
"""
We assume background in data structures and experience both in a procedural language
such as C, C++, or Java, and in Scheme.
"""



