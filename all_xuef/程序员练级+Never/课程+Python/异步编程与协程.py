#谈谈Python协程技术的演进
#https://zhuanlan.zhihu.com/p/30275154
"""
异步编程
说到异步非阻塞调用，目前的代名词都是 epoll 与 kqueue，select/poll 由于效率问题基本已被取代。

epoll 是04年 Linux2.6 引入内核的一种 I/O 事件通知机制，它的作用是将大量的文件描述符托管给内核，
内核将最底层的 I/O 状态变化封装成读写事件，这样就避免了由程序员去主动轮询状态变化的重复工作，
程序员将回调函数注册到 epoll 的状态上，当检测到相对应文件描述符产生状态变化时，就进行函数回调。

事件循环是异步编程的底层基石。


1. 用户创建了两个socket连接，将系统返回的两个文件描述符fd3、fd4通过系统调用在epoll上注册读写事件;
2. 当网卡解析到一个tcp包时，内核根据五元组找到相应的文件描述符，自动触发其对应的就绪事件状态，
并将该文件描述符添加到就绪链表中。
3. 程序调用epoll.poll()，返回可读写的事件集合。
4. 对事件集合进行轮询，调用回调函数等。
5. 一轮事件循环结束，循环往复。
"""

"""
1.5. 协程
EventLoop简化了不同平台上的事件处理，但是处理事件触发时的回调依然很麻烦，
响应式的异步程序编写对程序员的心智是一项不小的麻烦。

因此，协程被引入来替代回调以简化问题。协程模型主要在在以下方面优于回调模型：
1. 以近似同步代码的编程模式取代异步回调模式，真实的业务逻辑往往是同步线性推演的，
因此，这种同步式的代码写起来更加容易。底层的回调依然是callback hell，但这部分脏活
累活已经转交给编译器与解释器去完成，程序员不易出错。
2. 异常处理更加健全，可以复用语言内的错误处理机制，回调方式。而传统异步回调模式需要
自己判定成功失败，错误处理行为复杂化。
3. 上下文管理简单化，回调方式代码上下文管理严重依赖闭包，不同的回调函数之间相互耦合，
割裂了相同的上下文处理逻辑。协程直接利用代码的执行位置来表示状态，而回调则是维护了
一堆数据结构来处理状态。
4. 方便处理并发行为，协程的开销成本很低，每一个协程仅有一个轻巧的用户态栈空间。

"""

"""
就不同语言中面向并发设计的协程实现而言，Scala 与 Erlang 的 Actor 模型、Golang 中的
goroutine 都较 Python 更为成熟，不同的协程使用通信来共享内存，优化了竞态、冲突、不一致性等问题。
然而，根本的理念没有区别，都是在用户态通过事件循环驱动实现调度。


"""


"""
3. 从yield到async/await
3.1. 生成器的进化
直到在 Python2.5 中，yield 关键字被加入到语法中，这时，生成器有了记忆功能，
下一次从生成器中取值可以恢复到生成器上次 yield 执行的位置。

在 Python2.5 中生成器还加入了 send 方法，与 yield 搭配使用。
我们发现，此时，生成器不仅仅可以 yield 暂停到一个状态，还可以往它停止的位置通过 send 方法
传入一个值改变其状态。

在 Python3.3 中，生成器又引入了 yield from 关键字，yield from 实现了在生成器内调用另外生成器的功能，
可以轻易的重构生成器，比如将多个生成器连接在一起执行。

"""











