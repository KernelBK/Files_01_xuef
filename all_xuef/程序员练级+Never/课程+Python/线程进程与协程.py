
"""
进程，线程与协程
进程独有堆和栈
线程共享堆不共享栈

进程和线程由操作系统调度。
协程由程序员自己调度！

协程
可以暂停的函数，并且可以向暂停的地方传入值


A Common Theme
•You send data to coroutines
•You send data to threads (via queues)
•You send data to processes (via messages)
•Coroutines naturally tie into problems involving threads and distributed systems.
"""

"""
协程就是一种用户态内的上下文切换技术


根据维基百科给出的定义，“协程 是为非抢占式多任务产生子程序的计算机程序组件，
协程允许不同入口点在不同位置暂停或开始执行程序”。
从技术的角度来说，“协程就是你可以暂停执行的函数”。
如果你把它理解成“就像生成器一样”，那么你就想对了。

字典为动词“to yield”给出了两个释义：产出和让步。
yield item 这行代码会产出一个值，提供给 next(...) 的调用方；
此外，还会作出让步，暂停执行生成器，让调用方继续工作，
直到需要使用另一个值时再调用next()。调用方会从生成器中拉取值。

协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 .send(datum) 方法，
而不是 next(...) 函数。通常，调用方会把值推送给协程。
yield 关键字甚至还可以不接收或传出数据。
不管数据如何流动，yield 都是一种流程控制工具，使用它可以实现协作式多任务：协
程可以把控制器让步给中心调度程序，从而激活其他的协程。
"""
#从根本上把 yield 视作控制流程的方式，这样就好理解协程了。

#了解 Python 协程的进化过程有助于理解各个阶段改进的功能和复杂度。

##生成器的调用方可以使用 .send(...) 方法发送数据，
##发送的数据会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。
##协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。

##除了 .send(...) 方法，PEP 342 还添加了 .throw(...) 和 .close()方法：
##前者的作用是让调用方抛出异常，在生成器中处理；后者的作用是终止生成器。

##新引入了 yield from 句法，使用它可以把复杂的生成器重构成小型的嵌套生成器，
##省去了之前把生成器的工作委托给子生成器所需的大量样板代码。


##Python 3.3 引入 yield from 结构的主要原因之一与把异常传入嵌套的协程有关。
##另一个原因是让协程更方便地返回值。









