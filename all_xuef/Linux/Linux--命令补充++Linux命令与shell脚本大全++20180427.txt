
ls -R

ls -i

ls -a

rm -i f?all   # -i 询问  ? 匹配单个字符

mkdir -p New_Dir/Sub_Dir/Under_Dir

tree Small_Dir
rm -rf Small_Dir

file passwd

cat -n passwd


4.1 监测程序
Linux系统管理员面临的最复杂的任务之一就是跟踪运行在系统中的程序——尤其是现在，
图形化桌面集成了大量的应用来生成一个完整的桌面环境。系统中总是运行着大量的程序。

ps -ef

top [f d q]

1.  kill 命令
kill 命令可通过进程ID（PID）给进程发信号。
要发送进程信号，你必须是进程的属主或登录为root用户。

4.2 监测磁盘空间
系统管理员的另一个重要任务就是监测系统磁盘的使用情况。不管运行的是简单的Linux台
式机还是大型的Linux服务器，你都要知道还有多少空间可留给你的应用程序。

4.2.1 挂载存储媒体
如第3章中讨论的，Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒
体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。
在今天的图形化桌面环境里，大多数Linux发行版都能自动挂载特定类型的可移动存储媒体。
可移动存储媒体指的是可从PC上轻易移除的媒体，比如CD-ROM、软盘和U盘。
如果用的发行版不支持自动挂载和卸载可移动存储媒体，就必须手动完成。


4.3 处理数据文件
当你有大量数据时，通常很难处理这些信息及提取有用信息。
4.3.1 排序数据
处理大量数据时的一个常用命令是 sort 命令。

-n
-M

-k 和 -t 参数在对按字段分隔的数据进行排序时非常有用，例如/etc/passwd文件。可以用 -t
参数来指定字段分隔符，然后用 -k 参数来指定排序的字段。举个例子，要对前面提到的密码文件
/etc/passwd根据用户ID进行数值排序，可以这么做：
$ sort -t ':' -k 3 -n /etc/passwd

-n 参数在排序数值时非常有用，比如 du 命令的输出。
$ du -sh * | sort -nr
注意， -r 参数将结果按降序输出，这样就更容易看到目录下的哪些文件占用空间最多。
管道命令( | )将 du 命令的输出重定向到 sort 命令。


4.3.2 搜索数据
你会经常需要在大文件中找一行数据，而这行数据又埋藏在文件的中间。这时并不需要手动
翻看整个文件，用 grep 命令来帮助查找就行了。 grep 命令的命令行格式如下。
grep [options] pattern [file]

grep 命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep 的输出就是包
含了匹配模式的行。

如果要进行反向搜索（输出不匹配该模式的行），可加 -v 参数。
$ grep -v t file1
如果要显示匹配模式的行所在的行号，可加 -n 参数。
$ grep -n t file1
如果要指定多个匹配模式，可用 -e 参数来指定每个模式。
$ grep -e t -e f file1

默认情况下， grep 命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采
用特殊字符来定义怎样查找匹配的模式。

4.3.3 压缩数据

4.3.4 归档数据
tar -zxvf test.tar   (解压)



chap5
在生成子shell进程时，只有部分父进程的环境被复制到子shell环境中。这会对包括变量在内
的一些东西造成影响


5.3 理解 shell 的内建命令

5.3.1 外部命令
外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell
程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。

ps 就是一个外部命令。你可以使用 which 和 type 命令找到它。
$ which ps
/bin/ps
$
$ type -a ps
ps is /bin/ps
$
$ ls -l /bin/ps
-rwxr-xr-x 1 root root 93232 Jan 6 18:32 /bin/ps
当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令 ps 很
方便显示出它的父进程以及自己所对应的衍生子进程。
$ ps -f
UID PID PPID C STIME TTY TIME CMD
christi+ 2743 2742 0 17:09 pts/9 00:00:00 -bash
christi+ 2801 2743 0 17:16 pts/9 00:00:00 ps -f

说明 就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，这一点无论是
在命令行还是在脚本编写中都是极其有用的。发送信号（signaling）使得进程间可以通过
信号进行通信。

5.3.2 内建命令
内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一
体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。


2. 命令别名
alias 命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一
个名称，从而将输入量减少到最低。
你所使用的Linux发行版很有可能已经为你设置好了一些常用命令的别名。要查看当前可用
的别名，使用 alias 命令以及选项 -p 。
$ alias -p


chap6 使用Linux环境变量
Linux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统
信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解
去哪里设置相应的环境变量很重要。
本章将带你逐步了解Linux环境变量：它们存储在哪里，怎样使用，以及怎样创建自己的环
境变量。

6.2 设置用户定义变量

6.2.2 设置全局环境变量
$ my_variable="I am Global now"
$
$ export my_variable

6.3 删除环境变量
$ unset my_variable

在处理全局环境变量时，事情就有点棘手了。如果你是在子进程中删除了一个全局环境变量，
这只对子进程有效。该全局环境变量在父进程中依然可用。

6.4 默认的 shell 环境变量

6.5 设置 PATH 环境变量
当你在shell命令行界面中输入一个外部命令时（参见第5章），shell必须搜索系统来找到对应
的程序。 PATH 环境变量定义了用于进行命令和程序查找的目录。

如果命令或者程序的位置没有包括在 PATH 变量中，那么如果不使用绝对路径的话，shell是没
法找到的。如果shell找不到指定的命令或程序，它会产生一个错误信息。

$ PATH=$PATH:/home/christine/Scripts
窍门 如果希望子shell也能找到你的程序的位置，一定要记得把修改后的 PATH 环境变量导出。

对 PATH 变量的修改只能持续到退出或重启系统。这种效果并不能一直持续。在下一节中，
你会学到如何永久保持环境变量的修改效果。

6.6 定位系统环境变量
在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些
文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash shell的方式。启动bash
shell有3种方式：
1. 登录时作为默认登录shell
2. 作为非登录shell的交互式shell
3. 作为运行脚本的非交互shell

6.6.1 登录 shell
当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里
读取命令：
  /etc/profile
  $HOME/.bash_profile
  $HOME/.bashrc
  $HOME/.bash_login
  $HOME/.profile
/etc/profile文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行
这个启动文件。

6.6.2 交互式 shell 进程
如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入 bash 时启动），那
么你启动的shell叫作交互式shell。交互式shell不会像登录shell一样运行，但它依然提供了命令行
提示符来输入命令。
如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录
中的.bashrc文件。


6.6.3 非交互式 shell
最后一种shell是非交互式shell。系统执行shell脚本时用的就是这种shell。不同的地方在于它
没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。

那如果 BASH_ENV 变量没有设置，shell脚本到哪里去获得它们的环境变量呢？别忘了有些
shell脚本是通过启动一个子shell来执行的（参见第5章）。子shell可以继承父shell导出过的变量。
举例来说，如果父shell是登录shell，在/etc/profile、/etc/profile.d/ * .sh和$HOME/.bashrc文件中
设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。
要记住，由父shell设置但并未导出的变量都是局部变量。子shell无法继承局部变量。

6.6.4 环境变量持久化
现在你已经了解了各种shell进程以及对应的环境文件，找出永久性环境变量就容易多了。也
可以利用这些文件创建自己的永久性全局变量或局部变量。

对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修
改过的变量设置放在/etc/profile文件中，但这可不是什么好主意。如果你升级了所用的发行版，
这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。
最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变
量设置放在这个文件中。

在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。这一
点适用于所有类型的shell进程。但如果设置了 BASH_ENV 变量，那么记住，除非它指向的是
$HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。

小结
bash shell会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每
个bash会话设置标准环境变量。每次登录Linux系统，bash shell都会访问/etc/profile启动文件以及3
个针对每个用户的本地启动文件：$HOME/.bash_profile、$HOME/.bash_login和$HOME/.profile。
用户可以在这些文件中定制自己想要的环境变量和启动脚本。

下章将会深入介绍Linux文件的权限。对Linux新手来说，这可能是最难懂的。然而要写出优
秀的shell脚本，就必须明白文件权限的工作原理以及如何在Linux系统中使用它们。


chap7 理解Linux文件权限
缺乏安全性的系统不是完整的系统。系统中必须有一套能够保护文件免遭非授权用户浏
览或修改的机制。Linux沿用了Unix文件权限的办法，即允许用户和组根据每个文件
和目录的安全性设置来访问文件。本章将介绍如何在必要时利用Linux文件安全系统保护和共享
数据。

7.1 Linux 的安全性
7.1.1 /etc/passwd 文件

7.1.2 /etc/shadow 文件
/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow
文件，这让它比起/etc/passwd安全许多。
使用shadow密码系统后，Linux系统可以更好地控制用户密码。它可以控制用户多久更改一
次密码，以及什么时候禁用该用户账户，如果密码未更新的话。

7.1.3 添加新用户
在创建新用户时，如果你不在命令行中指定具体的值， useradd 命令就会使用 -D 选项所显示
的那些默认值。这个例子列出的默认值如下：
  新用户会被添加到GID为 100 的公共组；
  新用户的HOME目录将会位于/home/loginname；
  新用户账户密码在过期后不会被禁用；
  新用户账户未被设置过期日期；
  新用户账户将bash shell作为默认shell；
  系统会将/etc/skel目录下的内容复制到用户的HOME目录下；
  系统为该用户账户在mail目录下创建一个用于接收邮件的文件。
倒数第二个值很有意思。 useradd 命令允许管理员创建一份默认的HOME目录配置，然后把
它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系
统文件。


更改默认值非常简单：
# useradd -D -s /bin/tsch

7.1.4 删除用户


7.2 使用 Linux 组
7.2.1 /etc/group 文件

7.3 理解文件权限
7.3.1 使用文件权限符

7.3.2 默认文件权限
你可能会问这些文件权限从何而来，答案是 umask 。 umask 命令用来设置所创建文件和目录
的默认权限。

遗憾的是， umask 命令设置没那么简单明了，想弄明白其工作原理就更混乱了。第一位代表
了一项特别的安全特性，叫作粘着位（sticky bit）。这部分内容会在7.5节详述。
后面的3位表示文件或目录对应的 umask 八进制值。要理解 umask 是怎么工作的，得先理解
八进制模式的安全性设置。

了解八进制模式权限是怎么工作的之后， umask 值反而更叫人困惑了。我的Linux系统上默
认的八进制的 umask 值是 0022 ，而我所创建的文件的八进制权限却是 644 ，这是如何得来的呢？
umask 值只是个掩码。它会屏蔽掉不想授予该安全级别的权限。接下来我们还得再多进行一
些八进制运算才能搞明白来龙去脉。
要把 umask 值从对象的全权限值中减掉。对文件来说，全权限的值是 666 （所有用户都有读
和写的权限）；而对目录来说，则是 777 （所有用户都有读、写、执行权限）。
所以在上例中，文件一开始的权限是 666 ，减去 umask 值 022 之后，剩下的文件权限就成了 644 。

在大多数Linux发行版中， umask 值通常会设置在/etc/profile启动文件中（参见第6章），不过
有一些是设置在/etc/login.defs文件中的（如Ubuntu）。可以用 umask 命令为默认 umask 设置指定一
个新值。
$ umask 026

7.4 改变安全性设置
7.4.1 改变权限
chmod 命令用来改变文件和目录的安全性设置。该命令的格式如下：
chmod options mode file

$ chmod 760 newfile
options 为 chmod 命令提供了另外一些功能。 -R 选项可以让权限的改变递归地作用到文件和
子目录。你可以使用通配符指定多个文件，然后利用一条命令将权限更改应用到这些文件上。

7.4.2 改变所属关系
有时你需要改变文件的属主，比如有人离职或开发人员创建了一个在产品环境中需要归属在
系统账户下的应用。Linux提供了两个命令来实现这个功能： chown 命令用来改变文件的属主，
chgrp 命令用来改变文件的默认属组。

chown 命令的格式如下。
chown options owner[.group] file
可用登录名或UID来指定文件的新属主。
# chown dan newfile


本章最后讨论了如何使用设置组ID位来创建共享目录。SGID位会强制某个目录下创建的新
文件或目录都沿用该父目录的属组，而不是创建这些文件的用户的属组。这可以为系统的用户之
间共享文件提供一个简便的途径。
现在你已经了解了文件权限，下面就可以进一步了解如何使用实际的Linux文件系统了。下
一章将会介绍如何使用命令行在Linux上创建新的分区，以及如何格式化新分区以使其可用于
Linux虚拟目录。


chap9 安装软件
9.1 包管理基础
在深入了解Linux软件包管理之前，本章将先介绍一些基础知识。各种主流Linux发行版都采
用了某种形式的包管理系统来控制软件和库的安装。PMS利用一个数据库来记录各种相关内容：
  Linux系统上已安装了什么软件包；
  每个包安装了什么文件；
  每个已安装软件包的版本。
软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务
器称为仓库（repository）。可以用PMS工具来搜索新的软件包，或者是更新系统上已安装软件包。
软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。
PMS工具将会检测这些依赖关系，并在安装需要的包之前先安装好所有额外的软件包。
PMS的不足之处在于目前还没有统一的标准工具。不管你用的是哪个Linux发行版，本书到
目前为止所讨论的bash shell命令都能工作，但对于软件包管理可就不一定了。

PMS工具及相关命令在不同的Linux发行版上有很大的不同。Linux中广泛使用的两种主要的
PMS基础工具是 dpkg 和 rpm 。
基于Debian的发行版（如Ubuntu和Linux Mint）使用的是 dpkg 命令，这些发行版的PMS工具
也是以该命令为基础的。 dpkg 会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包。

基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是 rpm 命令，该命令是其PMS
的底层基础。类似于 dpkg 命令， rmp 命令能够列出已安装包、安装新包和删除已有软件。


ls /var/lib/rpm/

rpm -q httpd   # 查询是否安装
rpm -qa grep httpd # 查询所有
rpm -ql httpd   # 查询安装列表

rpm包默认安装位置

rpm -qf 系统文件名 # 文件所属安装包

yum list installed


9.3.2 用 yum 安装软件
用 yum 安装软件包极其简单。下面这个简单的命令会从仓库中安装软件包、所有它需要的库
以及依赖的其他包：
yum install package_name

yum -y install gcc # -y 一路yes

LANG=zh_CN.utf-8
LANG=en_US.UTF-8
## 组包安装
yum grouplist # 查询
yum groupinstall 组名

# rmp 软件安装位置
rpm --help | grep prefix
# 源码包安装位置(没有卸载命令；卸载方式是直接把安装目录干掉)
安装在指定位置，一般是
/usr/local/软件名

# 安装位置不同带来的影响
RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是:
/etc/rc.d/init.d/httpd start
service httpd start   # service搜索的是 /etc 目录

systemctl status httpd

而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行
服务的管理，如:
/usr/local/apache2/bin/apachectl start

# 源码包安装
1. 准备
1) 安装c语言编译器(因为源码包都是c语言写的)
rpm -qa | grep gcc # 查询是否安装gcc
2) 下载源码包(从哪儿来?)从官方网站下载来 .tar.gz


# 源码包 vs rpm包 选哪个?
如果是有众多客户端访问，那需要高效率，就选择源码包，如apache




chap10 vim
dw
删除当前光标所在位置的单词
d$
删除当前光标所在位置至行尾的内容
J
删除当前光标所在行行尾的换行符（拼接行）

10.1.5 查找和替换
/
要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（next）。

替换命令的格式是：
:s/old/new/
vim编辑器会跳到 old 第一次出现的地方，并用 new 来替换。可以对替换命令作一些修改来替
换多处文本。
  :s/old/new/g      替换光标所在乎所有 old 。
  :n,ms/old/new/g ：替换行号 n 和 m 之间所有 old 。
  :%s/old/new/g ：替换整个文件中的所有 old 。
  :%s/old/new/gc ：替换整个文件中的所有 old ，但在每次出现时提示。






chap11 构建基本shell脚本

shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给
另一个命令。shell可以让你将多个命令串起来，一次执行完成。
如果要两个命令一起运行，可以
把它们放在同一行中，彼此间用分号隔开。
$ date ; who

!!!xuef：真是一语道出真滴!!!

11.3 显示消息
大多数shell命令都会产生自己的输出，这些输出会显示在脚本所运行的控制台显示器上。很
多时候，你可能想要添加自己的文本消息来告诉脚本用户脚本正在做什么。可以通过 echo 命令
来实现这一点。如果在 echo 命令后面加上了一个字符串，该命令就能显示出这个文本字符串。
echo -n "同一行: "

11.4 使用变量
运行shell脚本中的单个命令自然有用，但这有其自身的限制。通常你会需要在shell命令使用
其他数据来处理信息。这可以通过变量来实现。变量允许你临时性地将信息存储在shell脚本中，
以便和脚本中的其他命令一起使用。

11.4.1 环境变量
你已经看到过Linux的一种变量在实际中的应用。第6章介绍了Linux系统的环境变量。也可
以在脚本中访问这些值。
shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用
户名、用户的系统ID（也称为UID）、用户的默认主目录以及shell查找程序的搜索路径。可以用
set 命令来显示一份完整的当前环境变量列表。

echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME

要显示美元符，你必须在它前面放置一个反斜线。
$ echo "The cost of the item is \$15"
The cost of the item is $15

11.4.3 命令替换
shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋
给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。
有两种方法可以将命令输出赋给变量：
  反引号字符（ ` ）
	 $() 格式

命令替换允许你将shell命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编
程中的一个主要组成部分。
要么用一对反引号把整个命令行命令围起来：
testing='date'
要么使用 $() 格式：
testing=$(date)

shell会运行命令替换符号中的命令，并将其输出赋给变量 testing 。注意，赋值等号和命令
替换字符之间没有空格。
这个例子毫无吸引人的地方（也可以干脆将该命令放在 echo 语句中），但只要将命令的输出
放到了变量里，你就可以想干什么就干什么了。


下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名。
#!/bin/bash
# copy the /usr/bin directory listing to a log file
today=$(date +%y%m%d)  # 注意date后有个空格
ls /usr/bin -al > log.$today

！！！xuef: tomcat的日志文件名就是这种格式！！！

today 变量是被赋予格式化后的 date 命令的输出。这是提取日期信息来生成日志文件名常用
的一种技术。 +%y%m%d 格式告诉 date 命令将日期显示为两位数的年月日的组合。
$ date +%y%m%d
140131


11.5 重定向输入和输出

11.6 管道
有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，只是有些笨拙。
rpm 命令通过Red Hat包管理系统（RPM）对系统（比如上例中的Fedora系统）上安装的软件
包进行管理。配合 -qa 选项使用时，它会生成已安装包的列表，但这个列表并不会遵循某种特定
的顺序。如果你在查找某个或某组特定的包，想在 rpm 命令的输出中找到就比较困难了。
$ rpm -qa | sort

在这个例子中， sort 命令的输出会一闪而过，所以可以用一条文本分页命令（例如 less 或
more ）来强行将输出按屏显示。
$ rpm -qa | sort | more

11.7 执行数学运算
另一个对任何编程语言都很重要的特性是操作数字的能力。遗憾的是，对shell脚本来说，这
个处理过程会比较麻烦。在shell脚本中有两种途径来进行数学运算。
11.7.2 使用方括号
bash shell为了保持跟Bourne shell的兼容而包含了 expr 命令，但它同样也提供了一种更简单
的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和
方括号（ $[ operation ] ）将数学表达式围起来。
$ var1=$[1 + 5]
$ echo $var1
6
$ var2=$[$var1 * 2]
$ echo $var2
12

bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。

11.7.3 浮点解决方案
bc
浮点运算是由内建变量 scale 控制的。必须将这个值设置为你希望在计算结果中保留的小数
位数，否则无法得到期望的结果。
$ bc -q
3.44 / 5
0
scale=4
3.44 / 5
.6880
quit

2. 在脚本中使用 bc
现在你可能想问bash计算器是如何在shell脚本中帮助处理浮点运算的。还记得命令替换吗？
是的，可以用命令替换运行 bc 命令，并将输出赋给一个变量。基本格式如下：
variable=$(echo "options; expression" | bc)

var1=$(echo "scale=4; 3.44 / 5" | bc)
echo The answer is $var1

11.8 退出脚本
11.8.1 查看退出状态码
Linux提供了一个专门的变量 $? 来保存上个已执行命令的退出状态码。对于需要进行检查的
命令，必须在其运行完毕后立刻查看或使用 $? 变量。它的值会变成由shell所执行的最后一条命令
的退出状态码。
$ date
Sat Jan 15 10:01:30 EDT 2014
$ echo $?
0
$
按照惯例，一个成功结束的命令的退出状态码是 0 。

到目前为止，脚本中的命令都是按照有序的方式一个接着一个处理的。在下章中，你将学习
如何用一些逻辑流程控制来更改命令的执行次序。

chap12 使用结构化命令
12.1 使用 if-then 语句
最基本的结构化命令就是 if-then 语句。 if-then 语句有如下格式。
if  command
then
  commands
fi
bash shell的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码（参见第11章）是 0
（该命令成功运行），位于 then 部分的命令就会被执行。

$  cat test3.sh
#!/bin/bash
# testing multiple commands in the then section
#
testuser=Christine
#
if grep $testuser /etc/passwd
then
  echo "This is my first command"
  echo "This is my second command"
  echo "I can even put in other commands besides echo:"
  ls -a /home/$testuser/.b*
fi


12.2  if-then-else 语句

if  command
then
  commands
else
  commands
fi

12.3 elif


12.4  test 命令

if [  condition ]
then
  commands
fi

12.4.3 文件比较
最后一类比较测试很有可能是shell编程中最为强大、也是用得最多的比较形式。

1. 检查目录
-d 测试会检查指定的目录是否存在于系统中。如果你打算将文件写入目录或是准备切换到某
个目录中，先进行测试总是件好事情。

if [ -d $jump_directory ]

2. 检查对象是否存在
-e 比较允许你的脚本代码在使用文件或目录前先检查它们是否存在。

3. 检查文件
-e 比较可用于文件和目录。要确定指定对象为文件，必须用 -f 比较。

4. 检查是否可读
在尝试从文件中读取数据之前，最好先测试一下文件是否可读。可以使用 -r 比较测试。

5. 检查空文件
应该用 -s 比较来检查文件是否为空，尤其是在不想删除非空文件的时候。要留心的是，当
-s 比较成功时，说明文件中有数据。

8. 检查所属关系
-O 比较可以测试出你是否是文件的属主。

10. 检查文件日期
最后一组方法用来对两个文件的创建日期进行比较。这在编写软件安装脚本时非常有用。有
时候，你不会愿意安装一个比系统上已有文件还要旧的文件。

-nt 比较会判定一个文件是否比另一个文件新。如果文件较新，那意味着它的文件创建日
期更近。 -ot 比较会判定一个文件是否比另一个文件旧。如果文件较旧，意味着它的创建日期
更早。

12.5 复合条件测试
if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：
  [ condition1 ] && [ condition2 ]
  [ condition1 ] || [ condition2 ]

if [ -d $HOME ] && [ -w $HOME/testing ]


12.6  if-then 的高级特性
bash shell提供了两项可在 if-then 语句中使用的高级特性：
  用于数学表达式的双括号
  用于高级字符串处理功能的双方括号


chap13 更多的结构化命令
你会了解如何重复一些过程和
命令，也就是循环执行一组命令直至达到了某个特定条件。本章将会讨论和演示bash shell的循环
命令 for 、 while 和 until 。

13.1  for 命令
重复执行一系列命令在编程中很常见。通常你需要重复一组命令直至达到某个特定条件，比
如处理某个目录下的所有文件、系统上的所有用户或是某个文本文件中的所有行。

bash shell提供了 for 命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个
值来执行已定义好的一组命令。下面是bash shell中 for 命令的基本格式。
for var in list
do
  commands
done
在 list 参数中，你需要提供迭代中要用到的一系列值。可以通过几种不同的方法指定列表
中的值。

13.1.1 读取列表中的值
for test in Alabama Alaska Arizona Arkansas California Colorado

for test in Nevada "New Hampshire" "New Mexico" "New York"

13.1.3 从变量读取列表
生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生
输出的命令，然后在 for 命令中使用该命令的输出。
$ cat test5
#!/bin/bash
# reading values from a file
file="states"
for state in $(cat $file)
do
  echo "Visit beautiful $state"
done
$ cat states
Alabama
Alaska
Arizona
Arkansas
Colorado
Connecticut
Delaware
Florida
Georgia

13.1.5 更改字段分隔符
造成这个问题的原因是特殊的环境变量 IFS ，叫作内部字段分隔符（internal field separator）。
IFS 环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字
符当作字段分隔符：
  空格
  制表符
  换行符
如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数
据字段的开始。在处理可能含有空格的数据（比如文件名）时，这会非常麻烦，就像你在上一个
脚本示例中看到的。

要解决这个问题，可以在shell脚本中临时更改 IFS 环境变量的值来限制被bash shell当作字段
分隔符的字符。例如，如果你想修改 IFS 的值，使其只能识别换行符，那就必须这么做：
IFS=$'\n'
将这个语句加入到脚本中，告诉bash shell在数据值中忽略空格和制表符。

一个可参考的安全实践是在改变 IFS 之前保存原
来的 IFS 值，之后再恢复它。
这种技术可以这样实现：
IFS.OLD=$IFS
IFS=$'\n'
<在代码中使用新的IFS值>
IFS=$IFS.OLD
这就保证了在脚本的后续操作中使用的是 IFS 的默认值。

还有其他一些 IFS 环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在
/etc/passwd文件中）。你要做的就是将 IFS 的值设为冒号。
IFS=:
如果要指定多个 IFS 字符，只要将它们在赋值行串起来就行。
IFS=$'\n':;"
这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用 IFS 字符解析数据没
有任何限制。

13.1.6 用通配符读取目录
最后，可以用 for 命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中
使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或
路径名的过程。
如果不知道所有的文件名，这个特性在处理目录中的文件时就非常好用。

# iterate through all the files in a directory
for file in /home/rich/test/*
do
  if [ -d "$file" ]
  then
    echo "$file is a directory"
  elif [ -f "$file" ]
  then
    echo "$file is a file"
  fi
done


13.3  while 命令

while [ $var1 -gt 0 ]

var1=$[ $var1 - 1 ]

13.6 循环处理文件数据
通常必须遍历存储在文件中的数据。这要求结合已经讲过的两种技术：
  使用嵌套循环
  修改 IFS 环境变量

通过修改 IFS 环境变量，就能强制 for 命令将文件中的每行都当成单独的一个条目来处理，
即便数据中有空格也是如此。一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行
中的数据。
典型的例子是处理/etc/passwd文件中的数据。这要求你逐行遍历/etc/passwd文件，并将 IFS
变量的值改成冒号，这样就能分隔开每行中的各个数据段了。
#!/bin/bash
# changing the IFS value
IFS.OLD=$IFS
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
	echo "Values in $entry –"
	IFS=:
	for value in $entry
	do
		echo " $value"
	done
done

内部循环会解析出/etc/passwd每行中的各个值。这种方法在处理外部导入电子表格所采用的
逗号分隔的数据时也很方便。

13.7 控制循环
你可能会想，一旦启动了循环，就必须苦等到循环完成所有的迭代。并不是这样的。有两个
命令能帮我们控制循环内部的情况：
  break 命令
  continue 命令

13.9 实例
现在你已经看到了shell脚本中各种循环的使用方法，来看一些实际应用的例子吧。循环是对
系统数据进行迭代的常用方法，无论是目录中的文件还是文件中的数据。下面的一些例子演示了
如何使用简单的循环来处理数据。

13.9.1 查找可执行文件
当你从命令行中运行一个程序的时候，Linux系统会搜索一系列目录来查找对应的文件。这
些目录被定义在环境变量 PATH 中。如果你想找出系统中有哪些可执行文件可供使用，只需要扫
描 PATH 环境变量中所有的目录就行了。如果要徒手查找的话，就得花点时间了。不过我们可以
编写一个小小的脚本，轻而易举地搞定这件事。


下一章将会讨论如何和shell脚本用户交互。shell脚本通常并不完全是自成一体的。它们需要
在运行时被提供某些外部数据。下一章将讨论各种可用来向shell脚本提供实时数据的方法。

























